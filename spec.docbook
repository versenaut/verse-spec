<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/sgml/docbook/xml-dtd-4.2/docbookx.dtd" [
 <!ENTITY Bez           "B&eacute;zier">

 <!ENTITY Types         SYSTEM "protocol/types.snip">
 <!ENTITY Commands      SYSTEM "protocol/cmd.snip">
 <!ENTITY Command-Index SYSTEM "protocol/cmd-indx.snip">
 <!ENTITY API           SYSTEM "protocol/api.snip">
 <!ENTITY GNUFDL        SYSTEM "fdl.xml">]
>

<book lang="en">

<bookinfo>
 <title>Verse Specification</title>
 <subtitle>A platform for sharing 3D data</subtitle>
 <author><firstname>Emil</firstname>  <surname>Brink</surname></author>
 <author><firstname>Eskil</firstname> <surname>Steenberg</surname></author>
 <copyright><year>2004</year><holder>PDC, KTH</holder></copyright>

 <legalnotice>
  <para>
   Permission is granted to copy, distribute and/or modify this document
   under the terms of the GNU Free Documentation License, Version 1.2
   with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
   A copy of the license is included in the section entitled
   <link linkend='gfdl'>GNU Free Documentation License</link>.
  </para>
 </legalnotice>
</bookinfo>

<preface id='preface'>
<title>Preface</title>
<abstract>
<title>Abstract</title>
<para>This is the Official Verse Specification. It is intended to fully specify the Verse platform,
by breaking it down into manageable parts and then describing each of those in an exhaustive manner.
</para>
<para>
This specification should be complete and precise enough to serve as the basis for creating a
new Verse implementation, while retaining compatibility on all levels with the existing one.
</para>
</abstract>
</preface>

<chapter id='introduction'>
<title>Introduction</title>
<para>
</para>
<sect1>
<title>What is Verse?</title>
<para>
Verse is a platform for building networked applications centered around sharing and processing 3D data.
It consists of three parts, on different levels of abstraction:
the <link linkend="datamodel">data model</link>,
the <link linkend="protocol">network protocol</link>, and
the <link linkend="api">programming interface</link>. Below are condensed descriptions of these
three parts, hoping to convey a general idea quickly.
<variablelist>
<varlistentry>
<term><link linkend="datamodel">Data Model</link></term>
<listitem>
<para>
Verse defines a data model, which in turn defines exactly how data is formatted and stored.
The model is optimized and tailored for handling data suitable for building very dynamic
and highly interactive virtual worlds.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><link linkend="protocol">Network Protocol</link></term>
<listitem>
<para>
In order to make the data model accessible remotely, Verse defines a set of commands that can
be used to interact with data hosted on some computer. This set of commands is encoded on the
network in the exact manner described by the network protocol specification.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><link linkend="api">Programming Interface</link></term>
<listitem>
<para>
To make creating applications that use the Verse data model and protocol easy, a reference
application programming interface (<acronym>API</acronym>) has been created.
</para>
</listitem>
</varlistentry>
</variablelist>
The sections linked by the terms above provide plenty of additional detail about these three
parts of the platform, and appear in the order recommended for reading them.
</para>
</sect1>

<sect1 id='about'>
<title>About this Document</title>
<para>
This document is intended to be a complete specification of the Verse system, in all its parts. It begins
by describing the data model, moves along to how the data model is made available over a network, and finally
talks about the Verse standard C application programming interface.
</para>
<para>
The reader is assumed to have a certain level of technical proficiency, since this document often has reason
to be rather low-level. The detail level can be said to increase over the three major parts, but this is more
of a general trend than a struct rule.
</para>
<para>
This document was written by Emil Brink, using an original document by Eskil Steenberg, and his reference
implementation of the Verse standard, as input. Most of the document was written in the
<ulink url='http://www.docbook.org/'>DocBook</ulink> format, although much of the highly structured data
(the type, command and API references) were created programmatically from custom XML data.
</para>
</sect1>

</chapter>

<chapter id="datamodel">
<title>Data Model</title>
<para>
One core part of Verse is a data model for storing 3D data detailed enough to describe a <quote>virtual world</quote>.
The data model tries hard to allow for as much flexibility as possible in what can be stored, while also trying
to be no larger than necessary. This section will describe this data model exhaustively, by presenting the the
abstractions and structures used to represent data throughout Verse. We begin with the underlying idea, the
almost-philosophical concept of perfect data.
</para>

<!-- DO NOT MENTION NODES YET! -->
<sect1>
<title>Perfect Data</title>
<para>
Verse's data model is designed around the philosophy of "perfect data". With this, it is meant that the data
doesn't describe <emphasis>how</emphasis> to render the graphics, but more how the graphics should look.
It is then up to each client to do a "best effort render" of the data. The idea is to support creation of
datasets that are as easy as possible to use independently of the application.
</para>
<para>
The 3D geometry data is based around a single primitive: subdivided polygons. A subdivided polygon is
an ordinary polygon that has been extended with information about its <emphasis>creases</emphasis>,
allowing subdivision algorithms to intelligently split the single polygon into several to create a
3:rd degree curved surface that is smooth. This means that you may display the graphics as
simple, planar, polygons, but you can also subdivide them to increase the smoothness of the surfaces.
Subdivision is compatible with a lot of existing 3D software, since you can convert polygons, B-splines,
patches and NURBs into subdivision surfaces without loss of precision.
</para>
<para>
The Verse data model has many features such as:
<itemizedlist>
<listitem><para>An advanced shader tree supporting surface properties like
color, texture, lighting and displacement.</para></listitem>
<listitem><para>High dynamic range textures.</para></listitem>
<listitem><para>Animation curves.</para></listitem>
<listitem><para>Generic surface properties for storing UV, color, selections and other data.</para></listitem>
<listitem><para>A system-wide <emphasis>tag system</emphasis> lets users store additional custom data.</para></listitem>
</itemizedlist>
</para>
<para>
Verse can store text that lets each object be associated with scripts; these scripts can be read and executed by a
client, which can run on the server side. This is a very flexible way of doing scripting, since engines
can be written by anyone and for any language, making Verse language-independent. In addition to the text node
and tags, object nodes can have generic method calls that can be passed between clients.
</para>
</sect1>

<sect1 id='sessions'>
<title>Sessions</title>
<para>
At the top level, Verse data is always associated with with a <emphasis>session</emphasis>. Session is a name for
the connection between two applications that talk using the Verse protocol. Typically, in such a situation, one
end is called the <emphasis>host</emphasis> and the other is the <emphasis>client</emphasis>.
</para>
<para>
Hosts are mainly passive, acting as containers of data made available to clients. Clients do all the work by
connecting to a host and manipulating (reading, writing, creating, editing, and generally using) the data held
by it. Several clients can connect to the same host simultaneously, and will then be given individual views of
the data contained on the server. Typically, much data will be shared, so that they both get the sensation of
being in the same world and so that data modified by one client is visible to all other clients.
</para>
<para>
At the user level, hosts are perceived as <quote>containing</quote> a world, and making it available to clients
through the Verse protocol. In this regard, Verse hosts are very similar to the server in any common client-server
system, such as a web server for instance. It stores content, and makes it available to clients through a well-defined
communications protocol.
</para>
</sect1>

<sect1 id="subscription">
<title>Subscription</title>
<para>
In order for the client side to be able to participate in the session created by connecting to a host, it must
ask the host for data. This is done by <emphasis>subscribing</emphasis> to data of interest. Only clients are
allowed to subscribe to data, and hosts are only allowed to send data to a client that has been explicitly
requested in the form of a subscription.
</para>
<para>
When a client first subscribes to some piece of data, such as a polygon mesh, the host must send the current
state of that data to the client. Then, whenever the data changes, it must send those changes to the client
for as long as the client remains a subscriber. From the client's point of view, there is no difference in
handling initial data being sent, and handling changes later on: they are all delivered in the same way which
makes it easy to deal data in this fashion.
</para>
<para>
<emphasis>All</emphasis> data made available by a Verse host can be accessed through subscription in one way
or another, and being a subscriber is generally required before data can be read or written easily.
</para>
<para>
There is no data that cannot be changed at any time during a session, which helps make the system very dynamic.
</para>
</sect1>

<sect1 id="nodes">
<title>Nodes</title>
<para>
All data in Verse is arranged into <emphasis>nodes</emphasis>. Nodes group data according to
it's character, and are optimized for storing one particular kind of data per node type. There
are seven distinct node types defined: Object, Geometry, Material, Bitmap, Text, Audio and Curve.
</para>
<para>
Nodes are identified <emphasis>within a session</emphasis> through numbers assigned by the host. All node IDs
are valid only inside that session; two clients running on the same physical machine but connected to the same
host cannot directly exchange node IDs with each other and expect a sensible result. See below for a portable
way to reference nodes, however.
</para>
<para>
As we shall see, most nodes have a lot of internal structure (layers, fragments, buffers, and channels), that
are always also identified using numerical IDs. Unlike node IDs, these numbers <emphasis>can</emphasis> be shared
as long as the context is also provided. So, if a host contains a geometry node that client A knows as node
number 4096, and client B knows as node number 8999, the layer that A thinks is 4096.17 will be the exact same
data as B sees as 8999.17. This is harder to explain easily than it is to understand, we hope.
</para>

<sect2>
<title>Common Data</title>
<para>
There are some data storage facilities shared by all nodes, regardless of the node's type. These are described
below.
</para>
<sect3>
<title>Name</title>
<para>
All nodes have, in addition to the numerical ID mentioned above, a textual name. Unlike the IDs, the names are
<emphasis>not</emphasis> session-specific but can be shared between sessions. Names should be unique across
all nodes.
</para>
</sect3>
<sect3>
<title>Tags</title>
<para>
<emphasis>Tags</emphasis> provide a place where applications can store custom data associated with a node. This
is handy for expressing things that do not fit straight into the data model, but are nevertheless required by
applications for processing. Tags are like variables in a programming language; they have a name (and a numerical
ID for reference, as always) and a value of a certain type. There are numerical and textual types, plus some more
intricate ones.
</para>
<para>
To ease management, tags are collected into <emphasis>tag groups</emphasis>. Tag groups are simply named containers
for tags, that allow related tags to be grouped together. Also, tag groups can be subscribed to which gives better
subscription granularity than if individual tags could be.
</para>
<para>
These are the types of tag values supported:
<informaltable>
<tgroup cols='2'>
<thead>
 <row>
  <entry align='center'>Name</entry>
  <entry align='left'>Description</entry>
 </row>
</thead>
<tbody>
 <row>
  <entry>VN_TAG_BOOLEAN</entry>
  <entry>Boolean value, i.e. true or false only.</entry>
 </row>
 <row>
  <entry>VN_TAG_UINT32</entry>
  <entry>Unsigned 32-bit integer value.</entry>
 </row>
 <row>
  <entry>VN_TAG_REAL64</entry>
  <entry>64-bit floating point value.</entry>
 </row>
 <row>
  <entry>VN_TAG_REAL64_VEC3</entry>
  <entry>Vector of three 64-bit floating point values.</entry>
 </row>
 <row>
  <entry>VN_TAG_LINK</entry>
  <entry>Link to another node.</entry>
 </row>
 <row>
  <entry>VN_TAG_ANIMATION</entry>
  <entry>Link to a <link linkend='n-curve'>curve node</link>. Subject to change.</entry>
 </row>
 <row>
  <entry>VN_TAG_BLOB</entry>
  <entry>Unstructured binary data (<quote>binary large object</quote>).</entry>
 </row>
</tbody>
</tgroup>
</informaltable>
A tag always has a value, which means that it always has exactly one type. It is possible to rename, delete,
and change the type of tags, as well as creating new ones of course. We will see later on how these actions
are performed, in the <link linkend='system-commands'>system commands</link> section.
</para>
</sect3>
</sect2>

</sect1>

<sect1 id="n-object">
<title>The Object Node</title>
<para>
The <emphasis>object node</emphasis> acts as the root for data storage in Verse's data model. Its purpose is to
represent <quote>objects</quote> in a virtual world. All data in nodes of other types goes unused unless it is connected
to a tree rooted in an object node. The object node itself does not hold much actual data, but it provides
a transform and various other features.
</para>
<sect2 id='obj-link'>
<title>Linking</title>
<para>
The object node has the ability to link to other nodes, specifying different properties (geometry, materials,
associated scripts and so son) of the represented object. Multiple object nodes may all link to the same geometry
node, to share the data and thus create several identical copies of an object.
</para>
<para>
Links are unidirectional, going <emphasis>from</emphasis> an object node and <emphasis>to</emphasis> the link
target which can be a node of any type. Links have textual names, which are used to denote the purpose of
the link (for instance, the main geometry link from an object node to a geometry node is named
<quote><literal>geometry</literal></quote>).
</para>
</sect2>
<sect2 id='obj-transform'>
<title>Transform</title>
<para>
The object node holds a full 3D transform, with translation, rotation and scaling components that are used
to orient the object in the world. The first two of these properties are modeled not only with absolute values,
but also with time derivatives i.e. speed and acceleration. There is also support for expressing <emphasis>drag</emphasis>,
allowing basic friction to be modeled.
</para>
<para>
For each of these properties, the value is calculated by a 3D vector equation like the following:
<informalequation>
<alt>p(t) = p0 + v0*t + a*t^2 / 2 + drag</alt>
<graphic fileref='media/transform-eq.png'/>
</informalequation>
Here, the symbol <varname>p</varname> is used to represent the transform property of interest,
<varname>p0</varname> is the last known absolute position, <varname>v0</varname> the set initial speed,
<varname>a</varname> the acceleration, and <varname>drag</varname> a friction term. The position is
a function of the time, <varname>t</varname>, and thus it is possible to extrapolate into the future
from the last known values of the various parameters. The equation is the same for both position and
rotation of an object. Verse does not currently provide support for extrapolating the scale part of
an object's transform.
</para>
<para>
Hosts will maintain values of an object's transform using fairly high numerical precision, but it is
possible for a client to request a lower precision to conserve bandwidth.
</para>
<para>
The object node is the <emphasis>only</emphasis> node to provide a transform. Other types of data
that need to be associated to a point in space need to do so by being linked from an object node
at the required position.
</para>
</sect2>
<sect2 id='obj-light'>
<title>Light Sources</title>
<para>
Every object node has the ability to become a light source and light the world. A light source on an object
is simply defined by giving it three floating point values that determine how much light is emitted in each
of the primary colors red, green and blue. These values are interpreted so that a perpendicular surface at
a distance of 1.0 unit from a light source whose intensity (in any color) is 1.0 gets a light level of 1.0
(as <quote>seen</quote> by a material node's light fragment, that is).
</para>
<para>
By default, the light intensity is set to 0.0 for all three colors. This means that no light is emitted.
</para>
<para>
The light described here is a simple <quote>point light</quote>, with an equal amount of light being emitted
in each direction spherically, centered on the object's position. To create a more sophisticated light,
create a link to a <link linkend='n-geometry'>geometry node</link> and label it <quote><literal>light</literal></quote>.
This has the semantics of defining an area light, which only emits light from the faces of the geometry.
</para>
</sect2>
<sect2 id="o-methods">
<title>Methods</title>
<para>
The object node has the ability to hold custom entry points, known as <emphasis>methods</emphasis>. Methods are
like procedures in a programming language, they are a representation of the abstract concept of a named
action that takes a set of parameters and can be executed (called) at will. Methods are arranged in the node
into a number of named <emphasis>groups</emphasis>. They do not have return values, and are thus asynchronous
in nature.
</para>
<para>
Once created, method calls can be emitted by any client and any client is free to respond to a method being
called. This mechanism allows clients to create representations of their interfaces inside the world held on
the host.
</para>
</sect2>
</sect1>

<sect1 id="n-geometry">
<title>The Geometry Node</title>
<para>
The Geometry node describes the shape of the geometry and any additional data that is assigned to the surface
of an object.
</para>
<para>
Verse has a single primitive when it comes to representing geometry: Catmull/Clark <emphasis>subdivision surfaces</emphasis>.
Subdivision allows a simple polygonal mesh to be refined, by letting the algorithm generate more polygons so
that the model finally becomes smooth. Rendering clients in Verse are free to apply subdivision to the meshes
stored, the <emphasis>intent</emphasis> is that they should in order to approach the ideal created by the
artist but they do not have to. Verse's subdivision surfaces support <emphasis>creases</emphasis> with which
one can control the degree of subdivision allowed for each vertex and edge.
</para>
<sect2>
<title>Structure</title>
<para>
The data held by a geometry node can be divided into vertex and polygon definitions. Vertex data describe positions
in a local 3D space, and polygons are created by referencing the vertices. All polygons have exactly three or four
corners (vertex references), there is no support for general N-sided polygons. There is always storage reserved for
four corners for a given polygon; if the three first references are valid and the fourth unused, the polygon is a
triangle. If also the fourth reference is to a valid vertex, it is a quadrillion. All polygons are two-sided, and
the front side references its vertices in a clockwise manner.
</para>
<sect3>
<title>Layers</title>
<para>
The geometry data is stored in <emphasis>layers</emphasis>, where each layer has a well-defined type. There are
layer types for storing data per vertex, per polygon corner, and per polygon face. <xref linkend="g-layer-table"/>
is a table that summarizes the available layer formats.
<table align="center" id="g-layer-table">
<title>Geometry Node Layer Types</title>
<tgroup cols="5" align="center">
<thead>
<row rowsep='1'>
 <entry>Name</entry>
 <entry>Enum Value</entry>
 <entry>Value Type</entry>
 <entry>Value Size, bits</entry>
 <entry>Values per Index</entry>
</row>
</thead>
<tbody>
<row>
 <entry align="right"><symbol>G_LAYER_VERTEX_XYZ</symbol></entry><entry><literal>0</literal></entry>
 <entry>Floating Point</entry>
 <entry>64</entry>
 <entry>3</entry>
</row>
<row>
 <entry align="right"><symbol>G_LAYER_VERTEX_UINT32</symbol></entry><entry><literal>1</literal></entry>
 <entry>Unsigned Integer</entry>
 <entry>32</entry>
 <entry>1</entry>
</row>
<row>
 <entry align="right"><symbol>G_LAYER_VERTEX_REAL</symbol></entry><entry><literal>2</literal></entry>
 <entry>Floating Point</entry>
 <entry>64</entry>
 <entry>1</entry>
</row>
<row>
 <entry align="right"><symbol>G_LAYER_POLYGON_CORNER_UINT32</symbol></entry><entry><literal>128</literal></entry>
 <entry>Unsigned Integer</entry>
 <entry>32</entry>
 <entry>4</entry>
</row>
<row>
 <entry align="right"><symbol>G_LAYER_POLYGON_CORNER_REAL</symbol></entry><entry><literal>129</literal></entry>
 <entry>Floating Point</entry>
 <entry>64</entry>
 <entry>4</entry>
</row>
<row>
 <entry align="right"><symbol>G_LAYER_POLYGON_FACE_UINT8</symbol></entry><entry><literal>130</literal></entry>
 <entry>Unsigned Integer</entry>
 <entry>8</entry>
 <entry>1</entry>
</row>
<row>
 <entry align="right"><symbol>G_LAYER_POLYGON_FACE_UINT32</symbol></entry><entry><literal>131</literal></entry>
 <entry>Unsigned Integer</entry>
 <entry>32</entry>
 <entry>1</entry>
</row>
<row>
 <entry align="right"><symbol>G_LAYER_POLYGON_FACE_REAL</symbol></entry><entry><literal>132</literal></entry>
 <entry>Floating Point</entry>
 <entry>64</entry>
 <entry>1</entry>
</row>
</tbody>
</tgroup>
</table>
</para>
<para>
The first layer, named <quote><literal>vertex</literal></quote> but sometimes refered to as the
<quote>base layer</quote>, is always of type <symbol>G_LAYER_VERTEX_XYZ</symbol>. The second layer is always
used to define the polygons of the subdivision mesh, and must have type <symbol>G_LAYER_POLYGON_CORNER_UINT32</symbol>
and be named <quote><literal>polygon</literal></quote>. These two layers are rigidly defined since a host must be
able to perform validity checking on them, and thus must be able to uniquely identify which layer is the base vertex
layer and which defines the polygons. They are always present in every geometry node.
</para>
<para>
Any other layers can have whatever type is required by the application. More layers than the two basic ones are
often required, for instance to create a texture-mapped surface layers are added to hold the U and V components of
the texture coordinates that define the mapping.
</para>
<para>
The REAL-typed layers can be read and written using either 32 or 64 bits by clients, but always occupy 64 bits in
the host memory. By allowing 32-bit subscriptions, clients that do not need the full precision can reduce their
bandwidth demands.
</para>
<para>
The way to think about layers, is as two <quote>stacks</quote>, one for vertices and one for polygons. The vertex
stack always includes a <quote>base layer</quote> of type <literal>V_G_LAYER_VERTEX_XYZ</literal> (with the numerical
ID 0 and the name <quote><literal>vertex</literal></quote>, while the polygon stack always has a
<literal>V_G_LAYER_POLYGON_CORNER_UINT32</literal> layer (with ID 1, and name <quote><literal>polygon</literal></quote>).
Other layers, when created, will end up in one of the stacks depending on whether it is a vertex or polygon layer.
The size of all layers in a stack is controlled by the size of the base layer of that stack, i.e. one of the
aforementioned always-present layers. As vertices and/or polygons are created, the defining data (the XYZ coordinates
or the vertex references, respectively) are placed in a slot in the base layer, and all other layers are grown to
provide a slot of data space of whatever type the layer has for the new addition. This slot is typically initialized
with a default value, to make it well-defined until explicitly set.
</para>
</sect3>
<sect3>
<title>Creases</title>
<para>
Crease information is used to control the subdivision algorithm, by specifying how sharp a crease a vertex
or edge should have it is possible to avoid getting all <quote>smoothed out</quote> objects. There are two
possible approached supported for the two creases: either they can all be set to a single constant, or crease
information can be stored in a layer and referenced that way. If a layer is used, it must be of type
<symbol>G_LAYER_VERTEX_UINT32</symbol> for vertex creases, and <symbol>G_LAYER_POLYGON_CORNER_UINT32</symbol>
for edges. These values are given the following interpretation: zero represents a smooth surface (no crease),
while <literal>MAX_UINT32</literal> should give the maximum amount of crease to the vertex or edge.
</para>
</sect3>
<sect3 id='geometry-bones'>
<title>Bones</title>
<para>
The geometry node can also store local transformations known as <emphasis>bones</emphasis>. Each bone has a name
and a numerical ID, a parent ID, a position, and a rotation. The name is used to reference a layer that defines the
influence of that particular bone on each vertex of the model. Such layers must be of type
<symbol>G_LAYER_VERTEX_UINT32</symbol> or <symbol>G_LAYER_VERTEX_REAL</symbol>. Integer layers are interpreted
as being in the range 0..1 by dividing each value by 4,294,967,295. The parent link defines hierarchies of bones,
i.e. <emphasis>skeletons</emphasis>. It can be set to a non-existing bone to indicate that no parent exists, and the
bone will then be at root level.
</para>
</sect3>
</sect2>
</sect1>

<sect1 id="n-material">
<title>The Material Node</title>
<para>
The material node is used to define surface properties of an object. It does this by defining a set of primitives,
known as <emphasis>fragments</emphasis>. Fragments are operators that process triplets of values, very suitable
for representing color but also re-usable for other properties of a surface. For colors, the standard interpretation
of a value is that 0 is black and 1 is white, but values can be outside this range (at both ends) without being
clipped or considered invalid.
</para>
<para>
To define e.g. color (the typical use for a material node), begin by creating an
output fragment, setting its type to <quote>color</quote>, and then create any further fragments as desired, linking
them to the root and each other to form the final material tree. The tree is then evaluated for every point of each
surface that uses that material, and the result used to control the final shading.
</para>
<sect2>
<title>Fragments</title>
<para>
<xref linkend="m-frags-enum"/> enumerates the defined fragment types, and also gives the numerical value associated
with each one. This number is used to identify a fragment type in the network protocol.
<table id="m-frags-enum">
<title>Material Node Fragment Type Enumeration</title>
<tgroup cols="3" align="center">
 <thead><row><entry>Name</entry><entry>Enum Value</entry><entry>Purpose</entry></row></thead>
 <tbody>
  <row><entry><link linkend="m-f-color"><symbol>M_FRAGMENT_COLOR</symbol></link></entry>
    <entry><literal>0</literal></entry>
    <entry align="left">Emits a constant color.</entry></row>
  <row><entry><link linkend="m-f-light"><symbol>M_FRAGMENT_LIGHT</symbol></link></entry>
    <entry><literal>1</literal></entry>
    <entry align="left">Represents light falling on a surface.</entry></row>
  <row><entry><link linkend="m-f-reflection"><symbol>M_FRAGMENT_REFLECTION</symbol></link></entry>
    <entry><literal>2</literal></entry>
    <entry align="left">Represents reflected light.</entry>
  </row>
  <row><entry><link linkend="m-f-transparency"><symbol>M_FRAGMENT_TRANSPARENCY</symbol></link></entry>
    <entry><literal>3</literal></entry>
    <entry align="left">Represents a transparent surface.</entry>
  </row>
  <row><entry><link linkend="m-f-geometry"><symbol>M_FRAGMENT_GEOMETRY</symbol></link></entry>
    <entry><literal>4</literal></entry>
    <entry align="left">Uses data from a geometry layer to create color.</entry>
  </row>
  <row><entry><link linkend="m-f-texture"><symbol>M_FRAGMENT_TEXTURE</symbol></link></entry>
    <entry><literal>5</literal></entry>
    <entry align="left">Does look-ups in a bitmap node.</entry>
  </row>
  <row><entry><link linkend="m-f-tag"><symbol>M_FRAGMENT_TAG</symbol></link></entry>
    <entry><literal>6</literal></entry>
    <entry align="left">Returns color from tag.</entry>
  </row>
  <row><entry><link linkend="m-f-noise"><symbol>M_FRAGMENT_NOISE</symbol></link></entry>
    <entry><literal>7</literal></entry>
    <entry align="left">Generates random noise.</entry>
  </row>
  <row><entry><link linkend="m-f-blender"><symbol>M_FRAGMENT_BLENDER</symbol></link></entry>
    <entry><literal>8</literal></entry>
    <entry align="left">Blends two inputs together.</entry>
  </row>
  <row><entry><link linkend="m-f-matrix"><symbol>M_FRAGMENT_MATRIX</symbol></link></entry>
    <entry><literal>9</literal></entry>
    <entry align="left">Transforms input through a matrix.</entry>
  </row>
  <row><entry><link linkend="m-f-ramp"><symbol>M_FRAGMENT_RAMP</symbol></link></entry>
    <entry><literal>10</literal></entry>
    <entry align="left">Interpolates in a table.</entry>
  </row>
  <row><entry><link linkend="m-f-alternative"><symbol>M_FRAGMENT_ALTERNATIVE</symbol></link></entry>
    <entry><literal>11</literal></entry>
    <entry align="left">Allows implementation to select between two alternatives.</entry>
  </row>
  <row><entry><link linkend="m-f-output"><symbol>M_FRAGMENT_OUTPUT</symbol></link></entry>
    <entry><literal>12</literal></entry>
    <entry align="left">The root of each material fragment graph, the final output.</entry>
  </row>
 </tbody>
</tgroup>
</table>
</para>

<para>
<xref linkend="m-frags-table"/> presents the defined fragment types. It gives a description for each one,
including its input fields and what operation it performs to generate its emitted color.
</para>
<para>
These are the types of <link linkend='m-f-output'>output</link> fragment that are currently defined:
<variablelist>
<varlistentry>
<term><literal>color</literal></term>
<listitem><para>The tree defines surface color. This is the most common use.</para></listitem>
</varlistentry>
<varlistentry>
<term><literal>displacement</literal></term>
<listitem><para>Displacement of a surface. Gives a displacement along the surface normal, with a displacement
distance exactly equal to the average of the sum of the components of the triplet reaching the output fragment.
In other words, the distance is (R+G+B)/3. This should be done in the coordinate space of the geometry being
displaced.</para></listitem>
</varlistentry>
<varlistentry>
<term><literal>audio</literal></term>
<listitem><para>This is pending, and has not yet been given a final interpretation.</para></listitem>
</varlistentry>
</variablelist>

<table id="m-frags-table">
<title>Material Node Fragment Type Descriptions</title>
<tgroup cols="2" align="center">
<thead>
<row>
 <entry>Name</entry>
 <entry>Description</entry>
</row>
</thead>
<tbody>

<row>
 <entry>Color</entry>
 <entry align="left">
  <anchor id="m-f-color"/><para>The color fragment emits a single constant floating point triplet, generally used to represent a
RGB color. It is defined by three simple fields:</para>
  <variablelist>
   <varlistentry>
    <term><type>real64</type> <varname>red</varname></term>
    <listitem><para>The red component of the color being emitted by this fragment.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>real64</type> <varname>green</varname></term>
    <listitem><para>The green component of the color being emitted by this fragment.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>real64</type> <varname>blue</varname></term>
    <listitem><para>The blue component of the color being emitted by this fragment.</para></listitem>
   </varlistentry>
  </variablelist>
 </entry>
</row>

<row>
 <entry>Light</entry>
 <entry align="left">
  <anchor id="m-f-light"/><para>The light fragment represents the amount of incoming light at a given point on a surface.
It does not compute any view-dependent reflective properties of the surface, unless the BRDF field
is used. The normal falloff ranges from zero to one, and defines the micro-geometry of the surface.
A value of zero represents a perfectly flat surface, while a value of one represents a surface whose
normals are randomly distributed.
  </para>
  <para>
  <variablelist>
   <varlistentry>
    <term><type>enum</type> <varname>type</varname></term>
    <listitem><para>The type of light computation the fragment represents. See <xref linkend="m-light"/> below.
     </para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>real64</type> <varname>normal_falloff</varname></term>
    <listitem><para>Describes the smoothness of the surface.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>node</type> <varname>brdf</varname></term>
    <listitem><para>A node.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>string</type> <varname>brdf_r</varname></term>
    <listitem><para>A red something.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>string</type> <varname>brdf_g</varname></term>
    <listitem><para>A green something.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>string</type> <varname>brdf_b</varname></term>
    <listitem><para>A blue something.</para></listitem>
   </varlistentry>
  </variablelist>
   <table id="m-light">
    <title>Light Types</title>
    <tgroup cols='3'>
     <thead>
      <row><entry>Type Name</entry><entry>Value</entry><entry>Description</entry></row>
     </thead>
     <tbody>
      <row><entry><symbol>M_LIGHT_DIRECT</symbol></entry><entry align="center">0</entry>
       <entry>The light falling directly on to a surface.</entry></row>
      <row><entry><symbol>M_LIGHT_AMBIENT</symbol></entry><entry align="center">1</entry>
       <entry>The environment's ambient light.</entry></row>
      <row><entry><symbol>M_LIGHT_DIRECT_AND_AMBIENT</symbol></entry><entry align="center">2</entry>
       <entry>Both direct and ambient light, added together.</entry></row>
      <row><entry><symbol>M_LIGHT_BACK</symbol></entry><entry align="center">3</entry>
       <entry>The light that falls upon the back side of the material.</entry></row>
     </tbody>
     </tgroup>
   </table>
  </para>
 </entry>
</row>

<row>
 <entry>Reflection</entry>
 <entry align="left">
  <anchor id="m-f-reflection"/><para>This fragment represents a view-dependent perfect reflection computation from
the evaluation point. The normal fall-off describes the micro-geometry in the same manner used by the
<link linkend="m-f-light">light</link> fragment.
  </para>
  <variablelist>
   <varlistentry>
    <term><type>real64</type> <varname>normal_falloff</varname></term>
    <listitem><para>Something.</para></listitem>
   </varlistentry>
  </variablelist>
 </entry>
</row>

<row>
 <entry>Transparency</entry>
 <entry align="left">
  <anchor id="m-f-transparency"/><para>This fragment represents the properties of the surface that is behind the
evaluation point. The refraction index represent how light is bent when passing through the surface, and the normal
fall-off describes the micro-geometry just as in the <link linkend="m-f-light">light</link> and
<link linkend="m-f-reflection">reflection</link> fragments.
  </para>
  <variablelist>
   <varlistentry>
    <term><type>real64</type> <varname>normal_falloff</varname></term>
    <listitem><para>Something.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>real64</type> <varname>refraction_index</varname></term>
    <listitem><para>The refraction index of the material. Obviously not trivial to implement.</para></listitem>
   </varlistentry>
  </variablelist>
 </entry>
</row>

<row>
 <entry>Geometry</entry>
 <entry align="left">
  <anchor id="m-f-geometry"/><para>The geometry fragment allows a material to reference properties defined in a
<link linkend="n-geometry">geometry node</link>. Any layer can be referenced, integer layers will be converted
to normalized floating-point (by dividing with the maximum for the type in question). If an XYZ-type layer is
being referenced, the values will be mapped to the RGB data space fragments use trivially (X becomes red, Y
becomes green, and Z becomes blue). These are the fields of the fragment:
  </para>
  <variablelist>
   <varlistentry>
    <term><type>string</type> <varname>layer_r</varname></term>
    <listitem><para>Which layer to use as source of red-channel values.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>string</type> <varname>layer_g</varname></term>
    <listitem><para>Which layer to use as source of green-channel values.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>string</type> <varname>layer_b</varname></term>
    <listitem><para>Which layer to use as source of blue-channel values.</para></listitem>
   </varlistentry>
  </variablelist>
  <para>
  There is no node reference in this fragment; this is because the layers being referenced are always
(implicitly) taken to be in the current object's geometry node. This is typically the only practical
approach anyway, since e.g. UV-mapping data must be closely coupled to the geometry data in order to
be applicable; referencing layers in the same node helps ensure this.
  </para>
 </entry>
</row>

<row>
 <entry>Texture</entry>
 <entry align="left">
  <anchor id="m-f-texture"/><para>The texture fragment uses the incoming color as a point in 3D space mapped onto
a bitmap, and returns the value of the pixel at that point. It is used, with the <link linkend="m-f-geometry">geometry
fragment</link>, to express plain old texture-mapping. It has the following fields:
  </para>
  <variablelist>
   <varlistentry>
    <term><type>node</type> <varname>bitmap</varname></term>
    <listitem><para>A bitmap node to read texture data from.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>string</type> <varname>layer_r</varname></term>
    <listitem><para>Which layer to use as source of red-channel values.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>string</type> <varname>layer_g</varname></term>
    <listitem><para>Which layer to use as source of green-channel values.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>string</type> <varname>layer_b</varname></term>
    <listitem><para>Which layer to use as source of blue-channel values.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>fragment</type> <varname>control</varname></term>
    <listitem><para>The ID of a fragment whose output is used as the mapping, see above.</para></listitem>
   </varlistentry>
  </variablelist>
 </entry>
</row>

<row>
 <entry>Tag</entry>
 <entry align="left">
  <anchor id="m-f-tag"/><para>Tag fragments allow picking a constant color from a tag. The parent object node
can override the material node's tags. It is defined by the following fields:
  </para>
  <variablelist>
   <varlistentry>
    <term><type>string</type> <varname>group</varname></term>
    <listitem><para>The name of the tag group the tag belongs to.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>string</type> <varname>tag</varname></term>
    <listitem><para>The name of the desired tag.</para></listitem>
   </varlistentry>
  </variablelist>
 </entry>
</row>

<row>
 <entry>Noise</entry>
 <entry align="left">
  <anchor id="m-f-noise"/><para>The noise fragment takes a single input color, and uses it as a lookup in a
noise function. These are the types of noise currently supported:
<table>
 <title>Noise Fragment Types</title>
 <tgroup cols='3'>
  <thead>
   <row><entry>Type Name</entry><entry>Value</entry><entry>Generated Noise</entry></row>
  </thead>
  <tbody>
   <row><entry><symbol>M_NOISE_PERLIN_ZERO_TO_ONE</symbol></entry><entry><literal>0</literal></entry><entry>Noise distributed in the
numerical range [0,1] inclusive.</entry></row>
   <row><entry><symbol>M_NOISE_PERLIN_MINUS_ONE_TO_ONE</symbol></entry><entry><literal>1</literal></entry>
  <entry>Noise distributed in the numerical range [-1,1] inclusive.</entry></row>
  </tbody>
 </tgroup>
</table>
  </para>
  <variablelist>
   <varlistentry>
    <term><type>enum</type> <varname>type</varname></term>
    <listitem><para>The type of noise to generate. A value from the table above.
    </para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>fragment</type> <varname>mapping</varname></term>
    <listitem><para>Input coordinate that is looked up in (or fed to) the noise function.</para></listitem>
   </varlistentry>
  </variablelist>
 </entry>
</row>

<row>
 <entry>Blender</entry>
 <entry align="left">
  <anchor id="m-f-blender"/><para>The blender fragment takes two input colors A and B (and sometimes a control
input), and blends them using a function chosen from the following list:
   <table>
    <title>Blender Fragment Types</title>
    <tgroup cols='3'>
     <thead>
      <row><entry>Type Name</entry><entry>Value</entry><entry>Function</entry></row>
     </thead>
     <tbody>
      <row><entry><symbol>M_BLEND_FADE</symbol></entry><entry align="center">0</entry>
       <entry>A * control + B * (1 - control)</entry></row>
      <row><entry><symbol>M_BLEND_ADD</symbol></entry><entry align="center">1</entry>
       <entry>A + B</entry></row>
      <row><entry><symbol>M_BLEND_SUBTRACT</symbol></entry><entry align="center">2</entry>
       <entry>A - B</entry></row>
      <row><entry><symbol>M_BLEND_MULTIPLY</symbol></entry><entry align="center">3</entry>
       <entry>A * B</entry></row>
      <row><entry><symbol>M_BLEND_DIVIDE</symbol></entry><entry align="center">4</entry>
       <entry>A / B</entry></row>
      <row><entry><symbol>M_BLEND_DOT</symbol></entry><entry align="center">5</entry>
       <entry>A.red * B.red + A.green * B.green + A.blue * B.blue</entry></row>
     </tbody>
     </tgroup>
   </table>
  </para>
  <variablelist>
   <varlistentry>
    <term><type>enum</type> <varname>type</varname></term>
    <listitem><para>The type of blend to produce. One of the values listed above.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>fragment</type> <varname>data_a</varname></term>
    <listitem><para>The <quote>A</quote> source data.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>fragment</type> <varname>data_b</varname></term>
    <listitem><para>The <quote>B</quote> source data.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>fragment</type> <varname>control</varname></term>
    <listitem><para>The <quote>control</quote> data needed for some of the functions.</para></listitem>
   </varlistentry>
  </variablelist>
 </entry>
</row>

<row>
 <entry>Matrix</entry>
 <entry align="left">
  <anchor id="m-f-matrix"/><para>The matrix fragment runs its input values through a 4x4 transformation matrix.
Since the data passed between fragments is defined to be only triplets, they are considered extended with a
fourth element with the value zero for these purposes.
  </para>
  <variablelist>
   <varlistentry>
    <term><type>array of real64</type> <varname>matrix</varname></term>
    <listitem><para>The matrix itself, defined as 16 floating point values in row-major order.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>fragment</type> <varname>data</varname></term>
    <listitem><para>The input data to transform.</para></listitem>
   </varlistentry>
  </variablelist>
 </entry>
</row>

<row>
 <entry>Ramp</entry>
 <entry align="left">
  <anchor id="m-f-ramp"/><para>A one-dimensional ramp (or curve) defined as an array of (position,color) tuples.
It takes a color as input, and selects a single channel. The value of that channel is then to do an interpolating
look-up in the ramp, and the resulting color is emitted.
<table id='m-f-ramp-type'>
 <title>Ramp Fragment Types</title>
 <tgroup cols='3'>
  <thead>
   <row><entry>Type Name</entry><entry>Value</entry><entry>Ramp Interpolation</entry></row>
  </thead>
  <tbody>
   <row><entry><symbol>M_RAMP_SQUARE</symbol></entry><entry><literal>0</literal></entry>
    <entry>Do no interpolation, just pick whatever value is closest in the ramp.</entry></row>
   <row><entry><symbol>M_RAMP_LINEAR</symbol></entry><entry><literal>1</literal></entry>
    <entry>Interpolate linearly between neighboring ramp values.</entry></row>
   <row><entry><symbol>M_RAMP_SMOOTH</symbol></entry><entry><literal>2</literal></entry>
    <entry>Interpolate bilinearly between ramp elements.</entry></row>
  </tbody>
 </tgroup>
</table>
<table id='m-f-ramp-channel'>
 <title>Ramp Channel Types</title>
 <tgroup cols='3'>
  <thead>
   <row><entry>Type Name</entry><entry>Value</entry><entry>Channel Selection</entry></row>
  </thead>
  <tbody>
   <row><entry><symbol>M_RAMP_RED</symbol></entry><entry><literal>0</literal></entry>
    <entry>Use the red component of incoming values to do the look-up.</entry></row>
   <row><entry><symbol>M_RAMP_GREEN</symbol></entry><entry><literal>1</literal></entry>
    <entry>Use the green component of incoming values to do the look-up.</entry></row>
   <row><entry><symbol>M_RAMP_BLUE</symbol></entry><entry><literal>2</literal></entry>
    <entry>Use the blue component of incoming values to do the look-up.</entry></row>
  </tbody>
 </tgroup>
</table>
 </para>
  <variablelist>
   <varlistentry>
    <term><type>enum</type> <varname>type</varname></term>
    <listitem><para>The type of interpolation desired in this ramp. Must be either a value from
<xref linkend='m-f-ramp-type'/> above.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>enum</type> <varname>channel</varname></term>
    <listitem><para>Which channel of the input should be used to do the look-up. Must be a value from
<xref linkend='m-f-ramp-channel'/> above.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term>array of (<type>real64</type> <varname>position,red,green,blue</varname>) <varname>ramp</varname></term>
<listitem><para>The ramp data itself. A maximum of 48 data points can be specified in a single ramp.</para></listitem>
   </varlistentry>
  </variablelist>
 </entry>
</row>

<row>
 <entry>Alternative</entry>
 <entry align="left">
  <anchor id="m-f-alternative"/><para>This fragment specifies two inputs, and allows the parser to select one and
ignore the other. The most preferable path should always be specified as the one labeled A. The intent is to allow
e.g. simpler materials to be defined in an alternative path.
  </para>
  <variablelist>
   <varlistentry>
    <term><type>fragment</type> <varname>alt_a</varname></term>
    <listitem><para>Alternative path A, the most preferable one.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term><type>fragment</type> <varname>alt_b</varname></term>
    <listitem><para>Alternative path B, the least preferable one.</para></listitem>
   </varlistentry>
  </variablelist>
 </entry>
</row>

<row>
 <entry>Output</entry>
 <entry align="left">
  <anchor id="m-f-output"/><para>The output fragment serves as the root for a material tree, and must be present
in a material node in order for it to have any effect. It is defined by the following fields:</para>
  <variablelist>
   <varlistentry>
    <term><type>string</type> <varname>type</varname></term>
    <listitem><para>What type of surface property is described by this output fragment.
See above for a list of the defined, well-known, output types.
</para></listitem>
   </varlistentry>
   <varlistentry>
    <term>fragment <varname>front</varname></term>
    <listitem><para>The ID of the fragment which defines the surface property for the front
side of polygons using this material.</para></listitem>
   </varlistentry>
   <varlistentry>
    <term>fragment <varname>back</varname></term>
    <listitem><para>The ID of the fragment which defines the surface property for the back
side of polygons using this material.</para></listitem>
   </varlistentry>
  </variablelist>
  <para>
  If the <varname>front</varname> field is given a valid, non-zero value, any surface using this material will
show it on its forward-facing side. If the <varname>back</varname> field is given a valid, non-zero value, it
will show up on the backward-facing sides. If <varname>front</varname> equals <varname>back</varname> and is the
ID of a valid fragment, the material will be double-sided. Leaving either <varname>front</varname> or
<varname>back</varname> set to zero (an invalid fragment ID) or set to an invalid value will make the
corresponding side of surfaces invisible.
  </para>
 </entry>
</row>

</tbody>
</tgroup>
</table>
</para>
</sect2>
<sect2>
<title>Examples</title>
<para>
This section contains a set of example fragment graphs, to illustrate how the various pieces of functionality
can be used together to create various actual materials.
</para>
<example>
<title>Plain Gray</title>
<para>
<figure id="m-ex-plain-gray">
<title>A Plain Gray Material</title>
<mediaobject>
 <imageobject>
  <imagedata fileref="media/material/plain-gray.png" format="PNG"/>
 </imageobject>
</mediaobject>
</figure>
<xref linkend="m-ex-plain-gray"/> shows a simple two-fragment material. This is about as simple as a material
can become, since a lone <link linkend="m-f-output">output</link> fragment is of little use. The added
<link linkend="m-f-color">color</link> fragment provides a constant medium-gray color for the entire surface.
</para>
<para>
The output fragment does not specify a value for the <varname>back</varname> field; meaning it's single-sided
(surfaces using this material will not be visible from their back side).
</para>
</example>
</sect2>
</sect1>

<sect1 id="n-bitmap">
<title>The Bitmap Node</title>
<para>
The bitmap node stores three-dimensional arrays of values. As the name implies, the intended use is to
store bitmap data, i.e. images. In a 3D-graphics system, images are usually used to <emphasis>texture</emphasis>
surfaces, so storing color data used for texturing is a common use for the bitmap node. It can also be used to
store other arrays of data needed to describe surface features, for things like displacement mapping, and of
course any application-specific data that is best expressed this way.
</para>
<para>
Bitmaps are often used as look-up tables for other operations, such as the texturing mentioned above. Since
these operations often need to use a relatively small amount of samples to cover a large screen area, filtering
techniques might need to be used to reduce artifacting by interpolating values between the ones present in
the bitmap itself.
</para>
<sect2>
<title>Bitmap Coordinates</title>
<para>
In their most general form, Verse bitmaps are three-dimensional <quote>cubes</quote> of samples (often called
<quote>pixels</quote>), with indepedent sizes in each of the three dimensions: width, height, and depth. They
can be restricted to only two or one dimension(s), which is frequently useful. Such a restriction is done by
setting the size in the required dimension(s) to one, and must be done from the end of dimension list. So, a
2D bitmap can only be created by setting the depth to one, not e.g. the height.
</para>
<para>
<figure id="b-ex-coords">
<title>Bitmap Coordinates</title>
<mediaobject>
 <imageobject>
  <imagedata fileref="media/bitmap/coords.png" format="PNG"/>
 </imageobject>
</mediaobject>
</figure>
Coordinates are in a <quote>screen-like</quote> space, with three axis called x, y and z. The pixel at (0,0,0) is
the leftmost, topmost, and foremost pixel. <xref linkend='b-ex-coords'/> shows the coordinate system used for bitmaps.
The Z, or depth, axis, is intended to go <quote>into</quote> the document, making this a right-handed coordinate
system.
</para>
</sect2>

<sect2>
<title>Layers</title>
<para>
Data in a bitmap node is arranged into <emphasis>layers</emphasis>. A single layer stores a full three-dimensional
(or restricted, see above) image. All layers in a node have the same size, that of the node itself. This size can
be re-set at any point, making all the layers grow or shrink as needed. Shrinking a node after data is been supplied
will effectively <emphasis>crop</emphasis> the layer data, permanently losing the data that falls outside the new
size. Layers have names that must be unique within the node, and a <emphasis>type</emphasis> that is one of the
following:
<table align="center" id="b-layer-table">
<title>Bitmap Node Layer Types</title>
<tgroup cols="4" align="center">
<thead>
<row>
 <entry>Name</entry>
 <entry>Enum Value</entry>
 <entry>Value Type</entry>
 <entry>Value Size, bits</entry>
</row>
</thead>
<tbody>
<row>
 <entry align="right"><symbol>B_LAYER_UINT1</symbol></entry><entry><literal>0</literal></entry>
 <entry>uint16, packed</entry>
 <entry>1</entry>
</row>
<row>
 <entry align="right"><symbol>B_LAYER_UINT8</symbol></entry><entry><literal>1</literal></entry>
 <entry>uint8</entry>
 <entry>8</entry>
</row>
<row>
 <entry align="right"><symbol>B_LAYER_UINT16</symbol></entry><entry><literal>2</literal></entry>
 <entry>uint16</entry>
 <entry>16</entry>
</row>
<row>
 <entry align="right"><symbol>B_LAYER_REAL32</symbol></entry><entry><literal>3</literal></entry>
 <entry>real32</entry>
 <entry>32</entry>
</row>
<row>
 <entry align="right"><symbol>B_LAYER_REAL64</symbol></entry><entry><literal>4</literal></entry>
 <entry>real64</entry>
 <entry>64</entry>
</row>
</tbody>
</tgroup>
</table>
</para>
<para>
Integer values are interpreted as being in the range of zero to one by dividing with the maximum value for
the respective sizes. Floating point values are not clamped to any range.
<note>
 <title>Expressing Color</title>
 <para>Since layers only provide a single value per pixel, you cannot express a typical RGB image using
 a single layer. Such images are stored by splitting them into three layers, one for each of the color
 components.</para>
</note>
</para>
<para>
The <symbol>B_LAYER_UINT1</symbol> format is slightly special, since there is no 1-bit integer type defined
in Verse. As we will see in subsequent sections, pixels in a 1-bit layer are expressed using the bits of
a single uint16 value.
</para>
</sect2>
<sect2>
<title>Tiles</title>
<para>
The smallest individually addressable part of a bitmap layer is a <emphasis>tile</emphasis>. A tile is simply
a small flat (two-dimensional) square of pixels in the XY plane of a bitmap layer. The standard tile size is
4x4 pixels. Tiles make bulk transfer of bitmap data in a network more efficient, by reducing addressing overhead.
</para>
<para>
Each layer is split into tiles by simply dividing it into 4x4 squares, beginning in the top left corner. This
creates a <quote>tile coordinate system</quote>. If the bitmap's dimensions are not integer multiples of the
tile side length, four, there will be tiles with only partial coverage of the bitmap. Any pixels in a tile
that fall outside of the bitmap itself will not be stored and should transmitted as zeros when transmission
is at all required.
</para>
<para>
Each tile is addressed using its tile coordinates in 2D, plus a Z coordinate that locates the tile in the
third dimension if applicable. For a 2D bitmap, Z will always be zero.
</para>
</sect2>
</sect1>

<sect1 id="n-text">
<title>The Text Node</title>
<para>
The text node, predictably, is used to store text. This text is not interpreted or <quote>understood</quote>
in any way defined by this specification; it is purely intended for application-specific use (hopefully conforming
to an auxiliary standard or set of guidelines).
</para>
<para>
The intended use for text nodes is to store programs in source code format, that can be linked to objects in order
to provide them with scripted <quote>behaviors</quote> through the use of <link linkend="o-methods">object methods</link>.
</para>
<sect2>
<title>Buffers</title>
<para>
Data in a text node is arranged into <emphasis>buffers</emphasis>. A buffer can be thought of as simply a named
text file; it consists of lines of text. Each buffer has a <emphasis>language</emphasis> field, which is simply
a text string that names the language used for the content of that buffer.
</para>
<para>
There is no default or <quote>native</quote> language specified in Verse; you are free to write clients to support
any language you chose, or to invent new languages. Such a client would typically implement a way for scripts to
access Verse by sending and receiving node commands, but need not mimic the reference implementation when doing so.
</para>
<para>
The language name <quote><literal>text</literal></quote> is reserved for text in natural languages. To specify a
single language, use a slash followed by an ISO 639:1988 standard code. Text in English would then be
<quote><literal>text/en</literal></quote>.
</para>
<para>
For programming language names, it is advised that the name is chosen to include a version number and a part that
identifies the kind of Verse application programming interface used. This is because there may be multiple APIs
defined for a single language, and interpreter clients need to determine if they should attempt to interpret a
buffer or not. For instance, a file written in C and using the reference API might have a language string of
<quote><literal>C/std</literal></quote>.
</para>
</sect2>
</sect1>

<sect1 id="n-curve">
<title>The Curve Node</title>
<para>
The curve node stores a set of curve definitions, defined as cubic &Bez; curves and optimized for dynamic
editing. The intended use is for animation, or other circumstances when there is a need to smoothly interpolate
a single parameter.
</para>
<sect2>
<title>Curves</title>
<para>
The content of a curve node is arranged into individual <emphasis>curves</emphasis>, with each curve having
its own content and being made available for subscription as single unit. Each curve is identified by a
numerical ID, just as with layers and buffers. Curves also have names, that must be unique within the same
node.
</para>
<para>
Curves are two-dimensional entities, existing in a special <quote>curve plane</quote>. The X (or <quote>pos</quote>)
dimension is time, while the Y (or <quote>value</quote>) dimension is unit-less. The way curves are used is
that the value from a curve is injected into some context to control something. For example, curves can be
used to control <link linkend='geometry-bones'>bone transformations</link>, creating smooth animation that
is easily controlled by editing curves rather than complex transforms directly. Or, they can be used to
control aspects of materials, or the light emitted by an object.
</para>
<sect3>
<title>Keys</title>
<para>
Each curve is made up of a set of <emphasis>key points</emphasis>, or keys for short. Taken all together,
the keys define the curve. A key is identified by the combination of the ID of the curve to which it belongs,
and an ID number for the key itself. A key is defined by three pairs of values; one actual absolute point
in the curve coordinate system, and two helper <quote>wings</quote> that define the angles at which the
curve enters and leaves the point:
<variablelist>
<varlistentry>
<term>(<type>real64</type> <varname>pos</varname>,<type>real64</type> <varname>value</varname>)</term>
<listitem><para>
The key's position on the curve. This is an actual point, that the curve passes through. No two keys can
have the same <varname>pos</varname> value, they must all be unique. Keys can occur in any order, there
is no relation between the value of a key's numerical ID and its <varname>pos</varname> field.
</para></listitem>
</varlistentry>

<varlistentry>
<term>(<type>uint32</type> <varname>pre_pos</varname>,<type>real64</type> <varname>pre_delta</varname>)</term>
<listitem><para>
Specification for one of the <quote>wings</quote> of the curve point. This wing gives the direction of the
curve as it approaches the point from the left. In relative format, see below for how to compute actual
control point.
</para></listitem>
</varlistentry>

<varlistentry>
<term>(<type>uint32</type> <varname>post_pos</varname>,<type>real64</type> <varname>post_delta</varname>)</term>
<listitem><para>
Specification for the other <quote>wing</quote> on the curve point. This wing gives the direction in which
the curve exits the point, to the right. In relative format, see below for how to compute actual control point.
</para></listitem>
</varlistentry>
</variablelist>
With these basic definitions out of the way, it is time to discuss how a curve is actually evaluated.
</para>
</sect3>

<sect3><title>Evaluating a Curve</title>
<para>
To form the &Bez; curve, the collection of keys is sorted by the <varname>pos</varname> field. This should
create a strictly increasing sequence of key points, all of which are passed through by the curve. Each segment
of the curve (between two key points) needs two additional <emphasis>control points</emphasis> to be able to
be evaluated as a &Bez; curve.
</para>
<para>
The following figure illustrates a part of a curve, showing three adjacent keys:
<figure id='curve' pgwide='0'>
 <title>Keys in a Curve</title>
 <mediaobject>
  <imageobject>
   <imagedata fileref='media/curve/curve.png' format='PNG'/>
  </imageobject>
 </mediaobject>
</figure>
The middle key, labeled <symbol>p1</symbol>, has its two wings (the short dashed lines ending in smaller filled
circles) shown. The first and last keys have only one wing each shown, to make the figure a little bit less
complex. This is merely an omission from the figure, there is no way to actually omit wings for a key point in
the Verse data model.
</para>
<para>
The wings are not immediately defined in the same coordinate space as the curve itself. The X component of a wing
is given as a <type>uint32</type> integer, and although the Y component is a <type>real64</type> just as the curve
point, it is not immediately compatible. To go from this specialized representation to coordinates in the key point
system, a few simple computations are needed.
</para>
<para>
The position part of a wing should be interpreted as a fraction between 0 and 1, encoded as a 32-bit unsigned
integer where 0 represents 0 and <literal>0xFFFFFFFF</literal> represents 1. This fraction is used to scale the
distance between the previous or next key, and the resulting value is subtracted (for the prev-wing) or added
(for the post-wing) to the key's position to end up with the actual control point coordinate.
</para>
<para>
Once the control point's X coordinate is known from the above computation, the value-deltas can be used to
compute the Y coordinate by multiplying with the same scaled distance as used for the X component, and then
adding (or subtracting) it to the key's Y coordinate.
</para>
<para>
So, to summarize, the prev-control point is computed like this:
<itemizedlist>
<listitem>
<para>Let <varname>d</varname> be the (negative) distance from this key to the previous, in the X dimension.</para>
</listitem>
<listitem>
<para>Let <varname>p</varname> be the fraction from the prev_pos field, i.e. the value of the prev_pos field divided
by <literal>0xFFFFFFFF</literal>. This is in the range [0,1].</para>
</listitem>
<listitem>
<para>The control point is then (<varname>pos</varname> + <varname>d</varname> * <varname>p</varname>,
      <varname>value</varname> + <varname>d</varname> * <varname>prev_value</varname>).</para>
</listitem>
</itemizedlist>
The post-control point is computed in a similar fashion but with <varname>d</varname> positive. Once this has been done,
we have the four points needed to compute a A single &Bez; curve segment: the curve from e.g. p1 to p2 uses p1 as its
starting position, p2 as its end, and uses p1's post-point and p2's prev-point as its two control points.
</para>
<para>
The relative way in which the control points are defined, using the wings, guarantees that the curve reacts nicely
to having new keys inserted between existing ones, and that the two wings can never be on the wrong side of their
parent key point. It is not possible to construct a curve with an <quote>S-shape</quote> using this system, which
keeps the curves well defined for all X values.
</para>
</sect3>

<sect3>
<title>Edges</title>
<para>
The curve needs to extend to infinity in both directions, although there of course cannot be that many keys.
It also needs to be well-defined even if there is only a single key, which is not (according to the evaluation
rules above) enough to form &Bez; curves.
</para>
<para>
The way this is resolved, is to simply introduce two implicit keys in all curves: one at a X distance of 1 to
the left of the first key, and one at a X distance of 1 to the right of the last one. The constant 1 was chosen
because in general the X dimension of curves is time, expressed in seconds, and for many movements one second
is a reasonable amount of time.
</para>
<para>
The curve is linear to the left of the first key, using that key's pre-wing to define the angle, and then linear
again to the right of the last key, using it's post-wing.
</para>
</sect3>

<sect3>
<title>Using Curves</title>
<para>
How curves are connected to the rest of the data model for actual use is a bit of a research issue at the
moment; we have some ideas that will appear in the spec and implementation soon.
</para>
</sect3>
</sect2>
</sect1>

<sect1 id="n-audio">
<title>The Audio Node</title>
<para>
The audio node provides support for streaming audio between Verse clients. It does not offer support for
storing audio permanently on a host, only for having layers (channels) of audio that one can subscribe to
and send/receive streaming audio content in.
</para>
<sect2>
<title>Layers</title>
<para>
Layers are simply independent <quote>places</quote> where audio data is sent. It might be helpful to think
of them as channels of a <quote>radio</quote> (the node), each of which can be subscribed to individually.
</para>
<para>
When a client requests to subscribe to an audio layer, it must also specify a desired <emphasis>transfer type</emphasis>
that controls how it wishes to have audio data sent to it.
</para>
</sect2>

<sect2>
<title>Transfer Types</title>
<para>
The audio supports two independent types of transfers: compressed and/or sustained. These can be combined
freely, so there are four different combinations that are all available. Note that the transfer type is not
a property of the audio layer, but of the subscription itself. It is possible to have one client, perhaps
using a limited bandwidth link, subscribe to a layer using compression, while the audio is being produced
by a close-to-the-host servlet using no compression.
</para>
<sect3><title>Compressed</title>
<para>
A compressed audio stream contains audio that is transmitted in compressed form. At this point (R2, June 2004)
little is known about compression algorithms, whether compression will be lossy or lossless, if algorithms
should be independent of this specification, and so on.
</para>
</sect3>
<sect3><title>Sustained</title>
<para>
A <emphasis>sustained</emphasis> audio stream is assumed to be flowing in real time, and any lost packets
in it will be ignored since there is no point in re-sending audio that should already have been played at
the time it arrives. A non-sustained stream, on the other hand, will have the regular resend algorithms
applied to its packets and is thus more suitable in e.g. an editing environment.
</para>
</sect3>
</sect2>
</sect1>

<sect1 id='subscription-graphs'>
<title>Subscription Graphs</title>
<para>
Data in Verse is accessed through <link linkend="subscription">subscription</link>. The data is arranged
hierarchically, so that a client needs to subscribe to increasingly more specialized <quote>areas</quote>
to reach it. The following sections describe these areas, for data that is available in all nodes (name,
tags) and for node type-specific data.
</para>
<sect2>
<title>Common Data</title>
<para>
The following figure represents the top-level common node data, that is available in all nodes:
<figure>
<title>Common Data Subscription Graph</title>
<mediaobject>
 <imageobject>
  <imagedata fileref="media/subscription-node.png" format="PNG"/>
 </imageobject>
</mediaobject>
</figure>
In this graph, a node (ellipse) represents a state a client can be in, with respect to what data it subscribes to.
The nodes are labeled with the names of the commands that it can receive in that state. Edges (labeled arrows)
represent commands sent by the client to the host, to request to subscribe to more (or less) data and thus change
the state. The list below describes each of the states for common node data:
</para>
<orderedlist>
<listitem>
<para>
The initial status, symbolized by the upper-most node labeled <quote>None</quote> is that the client knows
nothing about the available nodes. By sending a <xref linkend='node_list'/> command, the client can request
information about available nodes of a set of types (expressed as a mask, M). This request is a kind of
subscription, too, as the host must remember the mask and act according to it until it is changed.
</para>
</listitem>
<listitem>
<para>
Assuming nodes of the specified type(s) exist, the client will end up in a state where it receives the
<xref linkend='node_create'/> (and <xref linkend='node_destroy'/>) commands, providing it with information
about the existing nodes. 
</para>
</listitem>
<listitem>
<para>
By sending a <xref linkend='node_subscribe'/> command, the client can start subscribing to a node, which will then
move its state to the next node (marked with a double border). There, it will learn about the node's name and its
tag groups (if any). To find out about the contents of a tag group, it needs to use the
<xref linkend='tag_group_subscribe'/> command to request a subscription to it.
</para>
</listitem>
<listitem>
<para>
The final (bottom-most) node represents the state where a client has asked to subscribe to a tag group, and the
host will then send commands to describe its contents, i.e. the value of each tag in it.
</para>
</listitem>
</orderedlist>
<para>
Each client has a <quote>position</quote> in the above graph for each node it has learned about; it is perfectly
possible to subscribe to all tag groups of a single node while ignoring them completely for ten other.
</para>
</sect2>

<sect2>
<title>Object Node</title>
<para>
This graph begins with a double-bordered ellipse. This ties together with the double-bordered ellipse in the
previous graph, the one showing common node data. The two states are logically the same, but this graph shows
what can happen in the special case where the node is known to be an object node.
<figure>
<title>Object Node Subscription Graph</title>
<mediaobject>
 <imageobject>
  <imagedata fileref="media/subscription-o.png" format="PNG"/>
 </imageobject>
</mediaobject>
</figure>
</para>
<orderedlist>
<listitem>
<para>
Objects have <link linkend='obj-light'>light</link> and <link linkend='obj-link'>link</link> support, and the
information that describing it is sent to all object node subscribers. Also sent is information about available
method groups. There is a <link linkend='obj-transform'>transform</link>, too, which can be subscribed to although
no information about its existence is sent to node-level subscribers; it is always there so it is implicit.
</para>
</listitem>
<listitem>
<para>
Sending the <xref linkend='o_transform_subscribe'/> command switches to the bottom left state, and causes the
host to start sending updates to the object's transform.
</para>
</listitem>
<listitem>
<para>
Sending the <xref linkend='o_method_group_subscribe'/> command switches to the bottom right state, and causes the
host to start sending updates to the method group(s) in question.
</para>
</listitem>
</orderedlist>
<para>
It is important to realize that a client can be in both the bottom left and bottom right states at the same time,
by simply subscribing to both the transform and to one or more method groups. The states are not mutually exclusive.
</para>
</sect2>

<sect2>
<title>Geometry Node</title>
<para>
The double-bordered ellipse here is logically the same as the one in the common node data figure,
but this graph also shows what can happen when the node is known to be a geometry node.
<figure>
<title>Geometry Node Subscription Graph</title>
<mediaobject>
 <imageobject>
  <imagedata fileref="media/subscription-g.png" format="PNG"/>
 </imageobject>
</mediaobject>
</figure>
</para>
<para>
The geometry node, although one of the most data-rich nodes in Verse, has a rather shallow subscription space.
Once subscribed to a geometry node, a client will learn about the existing layers, and also get the definitions
of any bones defined in the node. Crease information is also sent to all subscribers. To get the geometry data,
a client needs to subscribe to the desired layer using <xref linkend='g_layer_subscribe'/>. Doing so forces the
client to chose a desired precision for any floating-point numbers in the layers.
</para>
<para>
Once subscribed to a layer, the client receives the layer's contents and any changes done for as long as it is
subscribed. Vertex data is delivered using ether <xref linkend='g_vertex_set_real32_xyz'/> or
<xref linkend='g_vertex_set_real64_xyz'/> depending on the requested precision. Polygon data is delivered using
one of the g_polygon_set commands, depending on the layer type.
</para>
</sect2>

<sect2>
<title>Material Node</title>
<para>
The double-bordered ellipse here is logically the same as the one in the common node data figure,
but this graph also shows what can happen when the node is known to be a material node.
<figure>
<title>Material Subscription Graph</title>
<mediaobject>
 <imageobject>
  <imagedata fileref="media/subscription-m.png" format="PNG"/>
 </imageobject>
</mediaobject>
</figure>
</para>
<para>
The material node contains no areas to which clients can subscribe, so this graph is very small. Just subscribing
to a material node is enough to learn about all the fragments in it.
</para>
</sect2>

<sect2>
<title>Bitmap Node</title>
<para>
The double-bordered ellipse here is logically the same as the one in the common node data figure,
but this graph also shows what can happen when the node is known to be a bitmap node.
<figure>
<title>Bitmap Subscription Graph</title>
<mediaobject>
 <imageobject>
  <imagedata fileref="media/subscription-b.png" format="PNG"/>
 </imageobject>
</mediaobject>
</figure>
</para>
<para>
The bitmap node's data is fairly simple in its organization. All subscribers to a bitmap node will learn about
its dimensions, and about available layers. To get at actual pixels, one needs to subscribe to the desired layer.
</para>
<para>
Having subscribed to a layer, its contents will be delivered (and kept up to date) by the host through the use of
the <xref linkend='b_layer_set_tile'/> command.
</para>
</sect2>

<sect2>
<title>Text Node</title>
<para>
The double-bordered ellipse here is logically the same as the one in the common node data figure,
but this graph also shows what can happen when the node is known to be a text node.
<figure>
<title>Text Subscription Graph</title>
<mediaobject>
 <imageobject>
  <imagedata fileref="media/subscription-t.png" format="PNG"/>
 </imageobject>
</mediaobject>
</figure>
</para>
<para>
The text node's data is arranged into buffers. When first subscribing to the node, a client will learn about the
language of the node's contents, and about the available buffers. To learn about a buffer, a client needs to send
the <xref linkend='t_buffer_subscribe'/> command.
</para>
<para>
Once subscribed to a buffer, a client will learn about its contents through receiving the
<xref linkend='t_text_set'/> command, as shown in the lower part of the figure.
</para>
</sect2>

<sect2>
<title>Curve Node</title>
<para>
The double-bordered ellipse here is logically the same as the one in the common node data figure,
but this graph also shows what can happen when the node is known to be a curve node.
<figure>
<title>Curve Subscription Graph</title>
<mediaobject>
 <imageobject>
  <imagedata fileref="media/subscription-c.png" format="PNG"/>
 </imageobject>
</mediaobject>
</figure>
</para>
<para>
The curve node's data is arranged into <emphasis>curves</emphasis>, each of which can be subscribed to as
a unit. When first subscribed to a curve node, a client will receive information about existing curves.
It can then choose to subscribe to a curve, by sending the <xref linkend='c_curve_subscribe'/> command.
</para>
<para>
Once subscribed to a curve, a client receives a copy of its contents (which continue to arrive if the contents
change) through the <xref linkend='c_curve_key_set'/> and <xref linkend='c_curve_key_destroy'/> commands.
</para>
</sect2>

<sect2>
<title>Audio Node</title>
<para>
The double-bordered ellipse here is logically the same as the one in the common data figure,
but this graph adds the audio-specific commands.
<figure>
<title>Audio Subscription Graph</title>
<mediaobject>
 <imageobject>
  <imagedata fileref="media/subscription-a.png" format="PNG"/>
 </imageobject>
</mediaobject>
</figure>
</para>
<para>
Audio data is arranged into <emphasis>layers</emphasis>, each of which can be subscribed to using the
<xref linkend='a_layer_subscribe'/> command. Once subscribed to a layer, a client will receive any data
sent out to it, through the <xref linkend='a_audio'/> command.
</para>
</sect2>

</sect1>

</chapter>

<chapter id="protocol">
<title>Network Protocol</title>

<sect1>
<title>Introduction</title>
<para>
This chapter describes the Verse network protocol. The purpose of the protocol is to make the
<link linkend='datamodel'>data model</link> available over a computer network. This is central to the Verse fundamental
idea, to make 3D graphics and audio data into something that can be shared by different applications over a network.
</para>
<para>
The description is arranged in a bottom-up manner, beginning by talking about how how data is abstractly
represented as various <link linkend='protocol-datatypes'>data types</link>, that are given concrete external
representations through <link linkend="protocol-encoding">encoding</link>. Encoded data is then arranged into
<link linkend="protocol-commands">commands</link>, which are finally turned into
<link linkend="protocol-packets">packets</link> for transmission.
</para>
</sect1>

&Types;

<sect1 id="protocol-encoding">
<title>Data Encoding</title>
<para>
The purpose of the network protocol is to allow data to be serialized and transmitted over a network in a
way that is independent of the machine type of the transmitting end. This requires well-defined ways to represent
various kinds of values, and how this is done is specified in this section. The discussion is split into sections
for each major type of value required by Verse;
<link linkend="protocol-encoding-ints">integers</link>,
<link linkend="protocol-encoding-reals">reals</link> (floating-point numbers),
<link linkend="protocol-encoding-strings">text strings</link>,
<link linkend="protocol-encoding-enums">enumerations</link>,
and
<link linkend="protocol-encoding-structs">structures</link>. There is also a description of how
<link linkend="protocol-encoding-arrays">arrays</link> of these value types are encoded.
</para>
<para>
Being external representations, all numerical types have well-defined sizes, in bits.
</para>

<sect2 id="protocol-encoding-ints">
<title>Integers</title>
<para>
All the various integers <link linkend='ints'>defined in Verse</link> are encoded as sequences of 8-bit
bytes, with the number of bytes trivially deductible from the bit-size of the integer type (simply divide
by eight). Encoding is done in <quote>network byte order</quote>, with the most significant byte first
(towards the start of a packet).
</para>
<!--
<para>
The exception is the <link linkend='type-uint1'>1-bit unsigned integer type</link>; since it is smaller
than one byte, the previous paragraph does not hold. Luckily, uint1s only occur in one place, and that's as an
array of length 16 which is simply represented as two bytes.
</para>
-->
<para>
Signed integers are encoded in two's complement form, with the most significant bit being the sign bit.
</para>
<para>
The various <link linkend='intaliases'>integer aliases</link> encode as the types they alias, respectively.
</para>
</sect2>

<sect2 id='protocol-encoding-reals'>
<title>Reals</title>
<para>
Reals are encoded as <ulink url='http://grouper.ieee.org/groups/754/'>IEEE 754</ulink> numbers, and occupy
four or eight bytes each depending on precision. The first byte in the encoded form holds the sign bit in its most significant bit,
followed by the biased exponent and finally the mantissa.
The general form for real numbers is thus:
<informaltable align='center'>
<tgroup cols='3'>
<thead>
<row>
 <entry align='center'>Type</entry>
 <entry align='center'>Sign Bit</entry>
 <entry align='center'>Exponent</entry>
 <entry align='center'>Mantissa</entry>
</row>
</thead>
<tbody>
<row>
 <entry><type>real32</type></entry>
 <entry align='center'>1</entry>
 <entry align='center'>8</entry>
 <entry align='center'>23</entry>
</row>
<row>
 <entry><type>real64</type></entry>
 <entry align='center'>1</entry>
 <entry align='center'>11</entry>
 <entry align='center'>52</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para>
</sect2>

<sect2 id='protocol-encoding-strings'>
<title>Strings</title>
<para>
<link linkend='strings'>Strings</link> are encoded in <ulink url='http://www.utf-8.com/'>UTF-8</ulink>. Briefly, this means that characters
with Unicode code points <literal>U+0001</literal> to <literal>U+007f</literal> (inclusive) are encoded as single
bytes with the value of the code point, while code points outside that range require multiple bytes. At most, a
single character requires four bytes to encode.
</para>
<para>
Strings use a byte with the value <literal>0</literal> to mark the end, so no string can contain that byte
legally. An empty string is thus encoded as a single byte with the value <literal>0</literal>.
</para>
</sect2>

<sect2 id='protocol-encoding-enums'>
<title>Enumerations</title>
<para>
All <link linkend='enums'>enumerations</link> encode as the <link linkend='type-uint8'><type>uint8</type></link>
integer type, and thus have had all their values chosen to fit in the numerical range of that type.
</para>
</sect2>

<sect2 id='protocol-encoding-structs'>
<title>Structures and Unions</title>
<para>
A <link linkend='structs'>structure</link> is encoded by encoding its fields, in order as they appear in the
definitions, end-to-end.
</para>
<para>
A union type is encoded by picking one of the fields, using external information, and then applying whatever
encoding rules apply to that field's type. The encoded size of a union is exactly the size of whichever
field was encoded, there is no padding of the union as a whole to the size of the largest field (unlike the
in-memory representation of unions in the C language).
</para>
</sect2>

<sect2 id='protocol-encoding-arrays'>
<title>Arrays</title>
<para>
Arrays are encoded simply as a sequence of values of the basic type, one after the other, and with no extraneous
information about number of elements as part of the actual array. For variable-length arrays, the length must be
encoded in some preceding field to allow proper decoding, as the length is not encoded automatically as part of
the array.
</para>
<para>
For arrays of unions, it must be specified where the information needed to resolve which union member is present
is stored, and if it is shared by all slots or not.
</para>
</sect2>

<sect2>
<title>Alignment</title>
<para>
Verse data is always encoded completely <emphasis>without padding</emphasis> after or between values. Since all
commands begin with the command byte, this means that the rest of the fields are almost guaranteed
<emphasis>not</emphasis> to be aligned in any particular manner. Thus, code that deals with doing encoding
and decoding must be carefully written.
</para>
<para>
Basically, accessing the command buffers on a byte-by-byte basis is the easiest way to do this safely. Doing whole
reads and writes of data types bigger than one byte (such as a <type>double</type> which is generally the way the
<type>real64</type> data type is implemented in C) using non-aligned addresses can often cause bad performance,
or even crashes.
</para>
<para>
The reference API implementation hides these details from users; application programmers using it need never concern
themselves with how Verse data is transported in a network.
</para>
<para>
No data type is smaller than a single byte; Verse data is encoded as a sequence of whole bytes.
</para>
</sect2>

<sect2><title>Examples</title>
<para>
Here are few simple examples of how values of the various types encode in the network. Encoded data is shown
as a sequence of bytes, where the leftmost byte would be the one towards the beginning of the packet.
</para>

<example>
<title>A signed integer</title>
<para>The integer <literal>-4711</literal>, taken as an <link linkend='type-int32'><type>int32</type></link>,
would be encoded like this:
<informaltable>
<tgroup cols='4' align='center'>
<tbody>
<row>
<entry><literal>0xff</literal></entry>
<entry><literal>0xff</literal></entry>
<entry><literal>0xed</literal></entry>
<entry><literal>0x99</literal></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para>
</example>

<example>
<title>An unsigned integer</title>
<para>The integer <literal>711</literal>, taken as an <link linkend='type-uint16'><type>uint16</type></link>,
would be encoded like this:
<informaltable>
<tgroup cols='2' align='center'>
<tbody>
<row>
<entry><literal>0x02</literal></entry>
<entry><literal>0xc7</literal></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</para>
</example>

<example>
<title>A Simple String</title>
<para>
The 10-character string <quote>Verse test</quote> would encode as the following sequence of eleven 8-bit bytes:
<informaltable>
<tgroup cols='11' align='center'>
<tbody>
<row>
<entry><literal>0x56</literal></entry> <!-- V -->
<entry><literal>0x65</literal></entry> <!-- e -->
<entry><literal>0x72</literal></entry> <!-- r -->
<entry><literal>0x73</literal></entry> <!-- s -->
<entry><literal>0x65</literal></entry> <!-- e -->
<entry><literal>0x20</literal></entry> <!-- SPC -->
<entry><literal>0x74</literal></entry> <!-- t -->
<entry><literal>0x65</literal></entry> <!-- e -->
<entry><literal>0x73</literal></entry> <!-- s -->
<entry><literal>0x74</literal></entry> <!-- t -->
<entry><literal>0x00</literal></entry> <!-- NUL -->
</row>
</tbody>
</tgroup>
</informaltable>
</para>
</example>

<example>
<title>An International String</title>
<para>The 7-character string <quote><foreignphrase>smrgs</foreignphrase></quote>
<footnote><para>Swedish for <quote>sandwich</quote></para></footnote>
encodes as the following 10-byte sequence using UTF-8:
<informaltable>
<tgroup cols='8'>
<tbody>
<row>
<entry><literal>0x53</literal></entry>  <!-- S -->
<entry><literal>0x6d</literal></entry>  <!-- m -->
<entry><literal>0xc3</literal></entry>  <!--  -->
 <entry><literal>0xb6</literal></entry> <!--  part 2-->
<entry><literal>0x72</literal></entry>  <!-- r -->
<entry><literal>0x67</literal></entry>  <!-- g -->
<entry><literal>0xc3</literal></entry>  <!--  -->
 <entry><literal>0xa5</literal></entry> <!--  part 2-->
<entry><literal>0x73</literal></entry>  <!-- s -->
<entry><literal>0x00</literal></entry>  <!-- NUL -->
</row>
</tbody>
</tgroup>
</informaltable>
Here, it is clear that a string using characters outside the range <literal>U+0001</literal> to <literal>U+007f</literal>
inclusive will use more space in their encoded form than a string that uses only characters from inside the range.
</para>
</example>
</sect2>

</sect1>

<sect1 id="protocol-commands">
<title>Node Commands</title>
<para>
A <emphasis>command</emphasis> is the unit of communication using Verse. Commands are sent between client and
host and express either global actions affecting the session as a whole, or address individual nodes directly.
</para>
<para>
The set of available commands is strictly defined in this specification, and Verse-compliant applications
cannot go outside it. This is because a goal with Verse is interoperability, and the set of commands needs to
be shared by all applications for this to be achieved. There are about 60 unique commands defined in this
specification.
</para>

<sect2>
<title>Structure</title>
<para>
The structure of a Verse network command is simple: a command is a finite sequence of bits. This sequence
consists of individual <emphasis>fields</emphasis> of varying length. A field is typically a value in one of
the supported network data formats and encoded according to the <link linkend="protocol-encoding">encoding standard</link>.
The first field has a fixed length of 8 bits, and always holds an integer value that identifies the command.
This field is called the <emphasis>command ID</emphasis> (or command byte) and completely determines the format
of the subsequent bits. The following bytes make up the command's <emphasis>parameters</emphasis>, which are
very much analogous to parameters in ordinary function calls.
</para>
<para>
The value of the initial command byte completely determines the exact format of the following bits, and also
how many bits are present. The size of a command need not be constant, however; there are both variable-length
single parameters (zero-terminated character strings) and parameters whose presence is determined by the
value of previous parameters in the same command.
</para>
<sect3>
<title>System vs. Node Commands</title>
<para>
There are two major categories of commands: system commands, and node commands. The defining difference
here is that system commands are not not sent to any specific node, they alter the session as a whole.
Node commands, on the other hand, are always sent to exactly one node. With this difference in mind, we
can present the following two schematic views of command structure:
<informaltable pgwide="1" frame="all">
<tgroup cols="3">
<tbody>
<row>
 <entry align="center"><para>
  <table frame="top">
   <title>A System Command</title>
   <tgroup cols="2">
    <tbody>
     <row>
      <entry>Field:</entry><entry>ID</entry><entry>parameters</entry>
     </row>
     <row>
      <entry>Width:</entry><entry align="center">8</entry><entry align="center">variable</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para></entry>
 <entry align="center"><para>
  <table>
   <title>A Node Command</title>
   <tgroup cols="4">
    <tbody>
     <row>
      <entry>Field:</entry><entry>ID</entry><entry>Node ID</entry><entry>parameters</entry>
     </row>
     <row>
      <entry>Width:</entry><entry align="center">8</entry><entry align="center">32</entry><entry align="center">variable</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para></entry>
</row>
</tbody>
</tgroup> 
</informaltable>
</para>
<para>
As can be seen, node commands differ from system commands by always including a 32-bit ID of the target node
as the first field following the command ID.
</para>
</sect3>
<sect3 id='cmd-addressing'>
<title>Addressing</title>
<para>
Many commands need to uniquely specify what data it reads or writes. This is done by concatenating a sequence of fields
in the encoded command, to form the <emphasis>address</emphasis>. For system commands, the command byte itself is
sometimes enough, and no further address fields are defined. For node commands, the address is extended to always
include the node ID field, and often further fields that address parts of the node.
</para>
<example id="ex-v-set-real32-addr">
<title><symbol>g_vertex_set_real32_xyz</symbol> Addressing</title>
<para>
As an example, consider setting the (X,Y,Z) position of a <link linkend="n-geometry">geometry node</link> base
layer vertex. One command that does this is
<link linkend='g_vertex_set_real32_xyz'><symbol>g_vertex_set_real32_xyz</symbol></link>,
which has a command ID value of <literal>50</literal>. This command requires three pieces of information that
together identify the vertex whose position is to be set: the node ID of the target node, the layer ID of the
layer holding the vertex, and finally the vertex ID that is the index of the vertex inside the layer. These three
values together make up the address part of the command.
</para>
<para>
In this case, we end up with a final address of (node ID, layer ID, vertex ID). Since the node ID is always 32
bits, and the layer and vertex IDs are 16 and 32 respectively, the address size is 32 + 16 + 32 = 80 bits.
</para>
</example>
</sect3>
<sect3>
<title>Content</title>
<para>
The rest of the parameters for a command make up the actual data payload, and little can be said about it in
general; the specific format is very much up to each command.
</para>
<example>
<title><symbol>g_vertex_set_real32_xyz</symbol> Content</title>
<para>
To continue from the previous example, the content used to set a vertex with 32-bit precision is simply
three <type>real32</type> values, named <varname>x</varname>, <varname>y</varname> and <varname>z</varname>
respectively. These add 3 * 32 = 96 bits to the command's parameter block, bringing the total size of the
command up to 8 + (32 + 16 + 32) + (3 * 32) = 184 bits, or 23 bytes.
</para>
</example>
</sect3>
</sect2>
<sect2 id='command-symmetry'>
<title>Command Symmetry</title>
<para>The way commands are actually used to convey information is interesting, and needs to be described
explicitly since it is perhaps not totally intuitive to everyone.
</para>
<para>
Verse node commands are very much like remote procedure calls; one end of a point-to-point network
connection can tell the other end to do something, like create a node. What makes them interesting is
the way in which the result of the operation is made known to the sender: typically, this is done by
<emphasis>sending the same command in the other direction</emphasis>, sometimes with a few values filled
in that were left blank originally.
</para>
<para>
This means that if a client sends a command to a host, asking it to e.g. move a vertex to a new position in
3D space (using the <command><link linkend='g_vertex_set_real32_xyz'>g_vertex_set_real32_xyz</link></command>
command), the following will happen:
<footnote>
<para>This example does not include sufficient detail to describe what happens if one or more commands are
lost in transit, which is always a possibility. But since packet-loss should be handled in a well-defined
manner, it can be ignored here.</para>
</footnote>
<orderedlist>
<listitem><para>The Verse network layer on the host receives the command, and notifies
<footnote><para>
In the standard API defined in this document, this notification is through the invocation of a
<emphasis><link linkend='api-callbacks'>callback function</link></emphasis>.
</para></footnote>
the host application.</para>
</listitem>
<listitem><para>
The host code validates the command, making sure it addresses a valid vertex, and that the sending client
has the right to execute the command. If it doesn't, processing ends here.
</para></listitem>
<listitem><para>
The host executes the command, typically by updating the state of the vertex layer with the new position.
</para></listitem>
<listitem><para>
The change must be distributed to all subscribers, probably also including the client that originally sent
the change. This is done by having the host construct a suitable command (for this example, this would be
the exact same command, i.e. a <command><link linkend='g_vertex_set_real32_xyz'>g_vertex_set_real32_xyz</link></command>),
and sending it out to all known subscribers.
</para></listitem>
<listitem><para>
The originating client's Verse network layer receives the update command, decodes it, and notifies the
application layer.
</para></listitem>
</orderedlist>
The point here is that the same sequence of bits (the command) is used both as a request from a client to
a host, to <quote>please set this object to this value</quote> and as an authoritative message in the other
direction, where the meaning is more along the lines of <quote>be advised, this object now has this value</quote>.
The distinction is subtle, but worth knowing about.
</para>
<para>
The above example is accurate, but only covers the case where there is a one-to-one correspondence between
the command received by the host and the command emitted by it in response to executing the request. Many
commands have a one-to-many relation instead; a client sends a single command, and the server responds with
a burst of many commands in return. This is common when requesting for a subscription to some data, for
example; the request is a single command, but the description of the data, which needs to be send to the
new subscriber, often requires several commands.
</para>
</sect2>
</sect1>

<sect1 id="protocol-packets">
<title>Packet Format</title>
<para>
Now that we have seen how Verse commands are formed, it is time to describe the particulars of how they
are actually transmitted over a network between machines. This involves the creation of <emphasis>packets</emphasis>
which are sent and received using UDP/IP.
</para>
<sect2>
<title>UDP/IP</title>
<para>
Verse always uses custom datagrams sent using UDP/IP as its transport mechanism. This is a core part of
this specification; you cannot just re-implement Verse to use e.g. TCP/IP and expect things to work; there
is a tight coupling between the transport mechanism and the command format (see <xref linkend="resend"/>).
Also, because Verse is designed and optimized for real-time performance, an area where TCP/IP has inherent
problems, such a re-implementation is not recommended.
</para>
<sect3>
<title>Ports</title>
<para>
The default port used by Verse is <literal>4950</literal>. This is the port a host will listen to, and also
the port a client will try to connect to if the supplied host address does not include an alternative number.
</para>
<para>
Once a client has connected to a host, it will be assigned a new port to use for further communication by the
host; in practice the default port is only used for the initial connection-establishment traffic.
</para>
</sect3>
</sect2>
<sect2>
<title>Packets</title>
<para>
Packets are built by simply encoding commands, end-to-end, and pre-pending a 16-bit header. There is no padding
between commands, and also no information in the header about which commands are contained in the packet. Since
commands do not have much of a header either, specifically they do not have a length indicator, to decode a packet
it is necessary to decode and interpret each command sequentially until the end of the packet is reached.
</para>
<para>
In order to reduce the overhead caused by the Internet Protocol's fragmentation handling, the reference implementation
of the Verse protocol will not emit packets larger than ~1,500 bytes. This limit has been chosen because it is the
maximum transferable unit (MTU) size of Ethernet, and the code simply assumes that the world is an Ethernet.
</para>
</sect2>
</sect1>

<sect1 id="resend">
<title>Resend Mechanism</title>
<para>
Each packet has a header consisting of a 32-bit packet ID. This packet ID increases with each packet sent, and makes
it possible for the receiving end to know if a particular packet has been lost during the transfer.
</para>
<para>
When an implementation notices one or more lost packets it will have to notify the other side by sending a
<emphasis>negative acknowledgment</emphasis> (<acronym>NAK</acronym>), and each packet that is successfully
received has to be confirmed by sending a <emphasis>positive acknowledgment</emphasis> (ACK).
</para>
<para>
The nak and ack commands are like any other command defined in the command specification. If a packet arrives,
all non-received commands since the last received commands are considered lost, and the implementation can immediately
decode and use the information in the arrived packet without waiting for data to be resent. If a lost packet later
arrives out of order, it should be ignored. Both sides must store history of sent data to be able to re-send any
data that may have been lost.
</para>
<para>
The NAK and ACK commands both include a single parameter; a 32-bit packet ID number. For NAK, the semantics are
that the indicated packet was lost and needs to be re-sent. The sending end must look it up in its packet history,
and re-send it. For ACK, the semantics are the inverse: the indicated packet was successfully received, and can
be removed from the history buffers.
</para>
<para>
If one side of a Verse connection fails, the other side's history buffer will eventually fill up. It is then free
to give up. Protocol implementations should provide a way for applications to determine how large the history
buffer is, so they can make the decision to terminate.
</para>
<sect2><title>Event Compression</title>
<para>
As described above, all commands sent out by a Verse application are buffered by the implementation, to be available
for resend should a NAK arrive. However, they are not simply buffered and forgotten until (possibly) re-sent. When
a command is added to the history buffer, a search is done for a command with the same <link linkend='cmd-addressing'>
address</link>. If a match is found, we know the one in the buffer has been made obsolete by the new command, and
it is thus <emphasis>replaced</emphasis> in the buffer. The comparison operation needed by the search can be implemented
in two discrete steps:
<itemizedlist>
<listitem><para>Compare the command bytes. If they differ, there can be no match.</para></listitem>
<listitem><para>Compare the address information. The address is always a contiguous sequence of bytes, and
has the same (fixed) size for all instances of a given command, so this is fairly simple.</para></listitem>
</itemizedlist>
Although the command byte and address information is always immediately adjacent in the encoded command format,
it is necessary to first inspect the command bytes to learn the size of the address information, which can vary
with each individual command.
</para>
<para>
This updating of sent commands with new data means that if a client repeatedly sends out N commands addressing the
same data (say, for instance, that it is periodically changing the color of some object), only one single command
will be stored in the history buffer. This way of automatically filtering out repeated changes to the same data,
keeping only the most recent, is called <emphasis>event compression</emphasis>.
</para>
<para>
Because of event compression, the command that is (re)sent in response to a NAK might not be the same command that
was actually lost, since it might have been replaced by a more recent command changing the same data.
</para>
</sect2>
</sect1>

<sect1 id='security'>
<title>Security</title>
<para>
At the time of writing (R2, June 2004), Verse has basically no security at the protocol level. There are planned
changes that will add encryption, but they have not yet been implemented.
</para>
</sect1>

<sect1 id="command-reference">
<title>Command Reference</title>
<para>This section forms a reference document that describes every defined network command in Verse.
For each command, it's complete network representation is given, and all included parameters are
described. Also described is the command's semantics, of course.</para>

<sect2>
<title>Command Semantics</title>
<para>There are two categories of network commands: system and node commands. System commands are sent to the
host itself, and are used to manage connections, and other administrative things. Node commands are sent to
actual node instances, and are used to describe the data contents.
</para>

<sect3>
<title>On Symmetry</title>
<para>
As <link linkend='command-symmetry'>noted earlier</link>, Verse commands are used both between client and
host to request something, and then in the reply from host to client to authoritatively state something. Often
the thing that is stated, the host's response, is the exact same thing that was requested but with one or
more values filled in that only the host knows about.
</para>
<para>
The descriptive texts for the commands in the following sections are written from <emphasis>the client's
perspective</emphasis> almost always. This means that e.g. the <xref linkend='g_vertex_set_real32_xyz'/> command
is described as <quote>setting the position of the vertex</quote>, rather than <quote>informing a client
about the position of a vertex</quote>, and so on.
</para>
<para>
This distinction is sometimes subtle, and well worth remembering when reading the command descriptions.
</para>
</sect3>

<sect3>
<title>Idempotent Commands</title>
<para>
All node commands contain an absolute <quote>address</quote>, in the form of node-dependent hierarchical
ID numbers, of the data being read or written. Most such node commands can be executed in any order, which
makes the protocol as a whole fairly free of command dependencies and the associated latencies. Because
of the addressing, most commands can also be executed multiple times without any harmful side effects
except (possibly) excessive network traffic. This latter property is sometimes referred to by saying that
the commands are <emphasis>idempotent</emphasis>.
</para>
<para>
While most commands are order-independent and idempotent, some commands can not be. For these commands,
there is a special transmission mode called <quote>ordered</quote>. Ordered commands must be delivered
to the receiving application in the order sent. This introduces latency, but is the only acceptable way
to deal with certain kinds of data.
</para>
</sect3>

<sect3>
<title>Being <quote>Done</quote></title>
<para>
Verse data transmissions can never be known to be <quote>complete</quote>, since even if your particular
client is a passive receiver only, you can never be sure that there isn't some other client connected
that is adding, editing, or deleting data.
</para>
<para>
This means clients can rarely be designed with some kind of hard separation into stages; i.e. you can't
say <quote>first I download the geometry, then I...</quote>, because there is no way of knowing when e.g.
the geometry has been <quote>fully</quote> downloaded. Indeed, the concept isn't even defined since
it can change at any moment.
</para>
<para>
This property means that any processing (for instance subdivision of geometry for rendering as triangles)
done on Verse data needs to be able to restart when data changes, and be ready to do so at any time.
</para>
</sect3>

</sect2>

</sect1>

<!-- Just include the entire protocol snippet, built separately from custom XML using XSLT. -->
&Commands;

<sect1 id="command-index"><title>Command Index</title>
<para>
Below is a table that lists all the defined commands, in numerical order. You can click a command
name to go to the definition page for that command. Aliased commands are shown with two names for
a single ID, separated by a slash.
&Command-Index;
</para>
</sect1>

</chapter>

<chapter id='api'>
<title>Standard API</title>
<sect1 id='api-intro'>
<title>Introduction</title>
<para>To simplify for Verse application programmers, there is a standard API defined here. This API, which is
written in C, is usable for implementing both Verse clients and hosts.
</para>
<sect2 id='api-goals'>
<title>API Goals</title>
<para>This section describes some of the design goals with the Verse standard API, motivates the choices,
and tells you what the API does and (sometimes more importantly) what it does not do for you, the application
programmer.
</para>
<para>
The Verse API has been designed to be basically a way to send and receive Verse commands, i.e. primarily
an implementation of the network protocol part of Verse. It does not include extensive support for the
<emphasis>data model</emphasis>, since that is considered outside its scope and can be built on top of
the API.
</para>
<para>
Thus, the API contains a function to send the command that describes e.g. a node to be created, but it does
not define any data structures or functions needed to actually represent a node according to the Verse data
model in memory. The design of the command set reflects this, and makes it possible to design as <quote>stupid</quote>
an API as possible. For instance, data format information is often repeated both in e.g. the command that
creates the data container (such as a layer) and in the command holding the data itself. This is because the command
set assumes that the API does not buffer the information on its own, so each command needs to be self-contained.
</para>
<para>
In use, the Verse API sits in between the application code and the underlying operating system. The API accepts the
application's requests to send commands, and do whatever is necessary to cause the operating system to actually emit
a properly-formed packet of data. Simultaneously, the API listens after incoming Verse packets, decodes them, and
delivers the contained data to the application.
</para>
<para>
It should be very possible to design an API that does more data buffering, perhaps of only meta information,
to hide this from the application programmer. We encourage such development.
</para>
</sect2>
<sect2>
<title>Choice of Language</title>
<para>
As stated above, the standard API is written in C, and made available as a C interface. This might be slightly
controversial, and worthy of further explanation. Of course, this topic is dangerously close to advocacy, which
is not the goal of this text. Still, below are some of the reasons why we feel C is a good choice.
<variablelist>
<varlistentry>
<term>Systems Programming</term>
<listitem><para>
The Verse API is intended to be the bottom-most layer between an application and the Verse network protocol,
and therefore it makes sense to use C, which is a traditional <quote>systems</quote> programming language task.
</para></listitem>
</varlistentry>

<varlistentry>
<term>Performance</term>
<listitem><para>
Since the Verse protocol layer might easily become a bottleneck in data-intensive applications, choosing
a language where it is possible to have detailed control of performance characteristics is natural. C is
such a language.
</para></listitem>
</varlistentry>

<varlistentry>
<term>Easily Wrapped</term>
<listitem><para>
To make Verse available from other programming languages, one approach is to <quote>wrap</quote> an existing
API in whatever interface is more natural in the target language. C is easily wrapped in this way, since it
is often used to <emphasis>implement</emphasis> other (primarily higher-level) languages.
</para></listitem>
</varlistentry>

</variablelist>
</para>
</sect2>

<sect2 id='api-callbacks'>
<title>About Callbacks</title>
<para>
When a command is received, the Verse API cannot handle the situation on its own, since it is too thin
a layer; it does not know what needs to be done when e.g. a vertex is moved, or a bitmap layer is created.
The API needs to pass the information that a command was received <quote>up</quote> and into the application
code where it can be dealt with.
</para>
<para>
Such event passing can be done in several ways, but the two major ones are probably by callbacks, and
by explicitly defining event data types and allowing applications to handle events as first-class entities. The
Verse API uses callbacks, which is arguably the smaller of the two approaches in terms of requirements on the API
itself (no need to define event data structures).

</para>
<para>
The callback approach requires two things:
<itemizedlist>
<listitem><para>That it is clearly defined how the callback for a given event should look. As will become
clear later, this is met by a simple symmetry between the API's functions for sending commands and functions
for handling notification, defined by the application programmer.</para></listitem>
<listitem><para>There must be a way for the application programmer to associate a callback with the
reception of a command. This is handled through the API's <xref linkend='verse_callback_set'/> function,
using send functions as keys.
</para></listitem>
</itemizedlist>
</para>
</sect2>

</sect1>

<sect1 id='api-overview'>
<title>API Overview</title>
<para>This section describes the top-level design of the API, which should make it easier to
understand. Each part is not enough to get any work done on its own; even the simplest application
must use functionality from at least two of the parts, and many typical clients will use them all.
</para>
<para>
The Verse standard API has been designed to be as easy as possible to work with, and also to be very
easy to integrate into program development. It has very few (if any) external code dependencies, and does
not rely on any libraries other than those that are included on standard operating systems (e.g. libraries
to deal with socket-level communication).
</para>
<para>
The library has a single header file, <filename>verse.h</filename>, which is included in all source code
files that wish to use the API. There is no need to initialize the API before using it, you can just go
ahead and call the desired functions right away.
</para>
<para>The API can be more or less dissected into three parts, where each parts contains functions for
solving similar problems. These parts are:
<variablelist>
 <varlistentry>
  <term><link linkend='api-ref-session'>Session Management</link></term>
  <listitem>
   <para>These are functions for working with <emphasis>sessions</emphasis>, which are connections from a
client to a host. There is also support for becoming a host here, and listen to incoming connections. Further,
there are functions for working with <emphasis>callbacks</emphasis>, which are a core part of the API.
</para>
  </listitem>
 </varlistentry>
 <varlistentry>
  <term><link linkend='api-ref-data'>Data Utility Functions</link></term>
  <listitem>
   <para>These are functions that help deal with complex data representations. Rather than have the
sending function (see below) do any required data conversions, it is left to an auxiliary function
in this group. This makes it possible to convert data once, then send it many times, which is necessary
for the efficient implementation of hosts (or multi-session clients).</para>
  </listitem>
 </varlistentry>
 <varlistentry>
  <term><link linkend='api-ref-commands'>Command Sending Functions</link></term>
  <listitem>
   <para>This is the largest group, by a large margin. It is basically a 1:1 mapping of
<link linkend="command-reference">commands</link> to functions, with one function to send each of the
defined commands for all node types. At the time of writing, there are roughly 80 such functions.</para>
  </listitem>
 </varlistentry>
</variablelist>
</para>
</sect1>

<sect1 id='api-typical-client'>
<title>A Typical Client</title>
<para>Since most Verse applications are assumed to be clients, it makes sense to spend a little extra
time here to outline how a typical client would use functions from the various parts of the API.
</para>
<para>
The general client will follow the following sequence of steps (links are to the API entry points most
relevant for each step):
<itemizedlist>
 <listitem>
  <para>Create session by connecting to host: <xref linkend='verse_send_connect'/>.
  </para>
 </listitem>
 <listitem>
  <para>Register callbacks for data the client expects to receive: <xref linkend='verse_callback_set'/>.
  </para>
 </listitem>
 <listitem>
  <para>Send initial list-command to learn about nodes on the host: <xref linkend='verse_send_node_list'/>.
  </para>
 </listitem>
 <listitem>
  <para>Enter main loop that polls network for commands, and runs appropriate callbacks:
   <xref linkend='verse_callback_update'/>.
  </para>
 </listitem>
 <listitem>
  <para>When needed, use data representation helper functions to process data that has been received
or that is to be sent.</para>
 </listitem>
</itemizedlist>
</para>
<para>For a host application, this list would look different.</para>
</sect1>

<sect1 id='api-ref-session'>
<title>Session Management Functions</title>

<refentry id='verse_send_connect' xreflabel='verse_send_connect()'>
<refnamediv>
<refname>verse_send_connect</refname>
<refpurpose>Create a connection to a Verse host</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>void <function>verse_send_connect</function></funcdef>
<paramdef>
 <parameter><type>const char *</type> name</parameter>,
 <parameter><type>const char *</type> pass</parameter>
 <parameter><type>const char *</type> address</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>
This function sends the connect command to a host, asking it to establish a new session.
</para>
</refsect1>
</refentry>

<refentry id='verse_send_connect_accept'>
<refnamediv>
<refname>verse_send_connect_accept</refname>
<refpurpose>Tell a client its connection request was accepted by a Verse host</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>void <function>verse_send_connect_accept</function></funcdef>
<paramdef>
 <parameter><type>VNodeID</type> avatar</parameter>,
 <parameter><type>const char *</type> address</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>
This function sends the connect_accept command, which informs a connecting client that the
connection attempt was successful and that it now has established a session with the host.
</para>
</refsect1>
</refentry>

<refentry id='verse_send_connect_deny'>
<refnamediv>
<refname>verse_send_connect_deny</refname>
<refpurpose>Deny a client from connecting to a Verse host</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>void <function>verse_send_connect_deny</function></funcdef>
<paramdef>
 <parameter><type>const char *</type> address</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>
This function sends the connect_deny command to a client, informing it that its connection attempt
failed. It takes a whole host address as an argument, since it is not sent though an established
connection.
</para>
</refsect1>
</refentry>

<refentry id='verse_send_connect_terminate'>
<refnamediv>
<refname>verse_send_connect_terminate</refname>
<refpurpose>Terminate a client's connection to a Verse host</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>void <function>verse_send_connect_terminate</function></funcdef>
<paramdef>
 <parameter><type>const char *</type> bye</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>
This function sends the connect_terminate command, which is used to disconnect from a host in a controlled
manner. It is sent by a client before destroying the session, to let the host know the client is about
to disconnect.
</para>
</refsect1>
</refentry>

<refentry id='verse_set_connect_port'>
<refnamediv>
<refname>verse_set_connect_port</refname>
<refpurpose>Set network port to use for incoming connections.</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>void <function>verse_set_connect_port</function></funcdef>
<paramdef>
 <parameter>uint16 port</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>
This function sets the UDP/IP port used to listen for incoming Verse connections. It is only used when
writing a host-type application. Clients that want to connect to a port other than the default simply
include the port in the host name specification when connecting (using host:port syntax). Using ports
lower than 1024 is usually not possible on Unix-style operating systems, since such ports are reserved
for <quote>well-known</quote> applications.
</para>
</refsect1>
</refentry>

<refentry id='verse_session_get'>
<refnamediv>
<refname>verse_session_set</refname>
<refpurpose>Make a session the current one, through which commands are sent</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>void <function>verse_session_set</function></funcdef>
<paramdef>
 <parameter>VSession session</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>
This function changes the current session. All callbacks are executed in the current session,
so to serve multiple connections a client must manually iterate through its sessions and call
<xref linkend='verse_callback_update'/>() in each.
</para>
</refsect1>
</refentry>

<refentry id='verse_session_get_size'>
<refnamediv>
<refname>verse_session_get_size</refname>
<refpurpose>Get size of session's packet history buffer</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>size_t <function>verse_session_get_size</function></funcdef>
<paramdef>
 <parameter>void</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>
This function returns the size of the (outbound) packet history buffer in the current session. It is a measure
of how well the network connection is working; if it is monotonically increasing over a longer period of time
(say, tens of seconds), that means data is not getting through to the other end, or that
<link linkend='packet_ack'>acknowledgments</link> of packets are not getting through in the other direction.
</para>
<para>
An application can use the value returned by this function to make a decision to drop the connection altogether,
if it exceeds some specific threshold. Such a threshold should be configurable.
</para>
</refsect1>
</refentry>

<refentry id='verse_session_destroy'>
<refnamediv>
<refname>verse_session_destroy</refname>
<refpurpose>Destroy a connection to a Verse host</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>void <function>verse_session_destroy</function></funcdef>
<paramdef>
 <parameter><type>VSession</type> session</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>This function destroys the given Verse session. Destroying a session does not send out the
<xref linkend='connect_terminate'/> command; you should do that manually.
</para>
<para>Destroying the current session will cause some other session to become current.
</para>
</refsect1>
</refentry>

<refentry id='verse_callback_set' xreflabel='verse_callback_set()'>
<refnamediv>
<refname>verse_callback_set</refname>
<refpurpose>Register a command callback, to be called when data arrives</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>void <function>verse_callback_set</function></funcdef>
<paramdef>
 <parameter><type>void *</type> send_func</parameter>,
 <parameter><type>void *</type> callback</parameter>,
 <parameter><type>void *</type> user_data</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>This function registers a callback to be called whenever a given Verse command is received.
</para>
<para>
The command is identified by providing, in <parameter>send_func</parameter>, the address of one of the
<xref linkend='api-ref-commands'/> functions. This is done since there has to
be a complete set of such functions available in any case, and making them serve <quote>double duty</quote> as
command identifiers saves the API from having to provide e.g. an enumeration representing all commands.
</para>
<para>
The second parameter, <parameter>callback</parameter>, is the user-defined callback that is going to be called, by
<xref linkend='verse_callback_update'/>, whenever the command in question is received.
</para>
<para>
The final argument, <parameter>user_data</parameter>, is a data pointer that is simply passed to the callback, the API
itself does not use or interpret it in any way.
</para>
</refsect1>
<refsect1><title>Callback Prototypes</title>
<para>Given a command-sending function X, the proper callback function has the exact same prototype but with a
single <type>void *</type> <varname>user_pointer</varname> prepended.
</para>
<para>
Because of the way the API is defined, with a single entry point (this one) that accepts values of a weak type, it is
possible to pass basically anything as the <parameter>callback</parameter> value. Since the API will call it, expecting
a function with the expected prototype, things can go horribly wrong if the wrong value has been supplied. Be careful.
</para>
</refsect1>
</refentry>

<refentry id='verse_callback_update' xreflabel='verse_callback_update()'>
<refnamediv>
<refname>verse_callback_update</refname>
<refpurpose>Empty incoming network queue, and call callbacks as necessary</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>void <function>verse_callback_update</function></funcdef>
<paramdef>
 <parameter><type>uint32</type> milliseconds</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>
This function reads any incoming packets from the network, parses them (splits them into commands) and issues
calls to any callbacks that are registered for the found commands. It will block for at most <parameter>milliseconds</parameter>
milliseconds and wait for something to arrive.
</para>
<note><para>An application must call this function periodically in order to service the connection with the other end
of the Verse link; failure to do so will cause the other end's packet buffer to grow which might cause the
connection to terminate.</para></note>
</refsect1>
</refentry>

</sect1>

<sect1 id='api-ref-data'>
<title>Data Processing Functions</title>
<para>Cool stuff.</para>

<refentry id='verse_method_call_pack'>
<refnamediv>
<refname>verse_method_call_pack</refname>
<refpurpose>Pack a method call for network transmission</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>VNOPackedParams * <function>verse_method_call_pack</function></funcdef>
<paramdef>
 <parameter><type>uint32</type> param_count</parameter>,
 <parameter><type>const VNOParamType *</type> param_type</parameter>,
 <parameter><type>const VNOParam *</type> params</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>
This function is used to pack a method call, prior to transmission. It accepts an array of
types, and an array of unions holding the actual values for each parameter. It creates and
returns a fairly opaque in-memory representation of the parameters, suitable for passing to
the method call sending function.
</para>
<para>
The reason this function exists is that some applications (such as host implementations) might
need to send the exact same set of parameters to several clients, and having the moderately
computationally intensive packing separate from the sending allows packing once and then re-using
the packed parameters for several sends.
<note>
<para>The current (release 2, June 2004) API implementation does not actually support doing this,
since <xref linkend='verse_send_o_method_call'/> will free the parameter block after sending it.</para>
</note>
</para>
</refsect1>
</refentry>

<refentry id='verse_method_call_unpack'>
<refnamediv>
<refname>verse_method_call_unpack</refname>
<refpurpose>Extract arguments from method call</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>boolean <function>verse_method_call_unpack</function></funcdef>
<paramdef>
 <parameter><type>const VNOPackedParams *</type> data</parameter>,
 <parameter><type>uint32</type> param_count</parameter>,
 <parameter><type>const VNOParamType *</type> param_type</parameter>,
 <parameter><type>VNOParam *</type> params</parameter>
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>
This function unpacks a memory block holding method call parameter values, as packed by
<xref linkend='verse_method_call_pack'/>() above, and fills in the supplied array of
<xref linkend='type-VNOParam'/> unions with the proper values. The <varname>param_type</varname>
array is used to determine the type of each argument, no such data is contained in the data block.
</para>
</refsect1>
</refentry>

<refentry id='verse_audo_compress'>
<refnamediv>
<refname>verse_audio_compress</refname>
<refpurpose>Compress audio data for network transmission</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>void * <function>verse_audio_compress</function></funcdef>
<paramdef>
 <parameter><type>uint32</type> length</parameter>,
 <parameter><type>VNALayerType</type> type</parameter>,
 <parameter><type>const void *</type> data</parameter>,
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>
This function compresses a sequence of raw audio samples into a more compact form, suitable for transmission using
a compressed audio layer.
</para>
</refsect1>
</refentry>

<refentry id='verse_audio_uncompress'>
<refnamediv>
<refname>verse_audio_uncompress</refname>
<refpurpose>Uncompress audio data for playback</refpurpose>
</refnamediv>
<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
<funcdef>void * <function>verse_audio_uncompress</function></funcdef>
<paramdef>
 <parameter><type>uint32</type> length</parameter>,
 <parameter><type>VNALayerType</type> type</parameter>,
 <parameter><type>const void *</type> data</parameter>,
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>
<refsect1><title>Description</title>
<para>This function decompresses a block of compressed audio data, restoring it to raw sample form which is
suitable for playback.
</para>
</refsect1>
</refentry>

</sect1>

<sect1 id='api-ref-commands' xreflabel='command sending'>
<title>Command Sending Functions</title>
&API;
</sect1>

</chapter>

&GNUFDL;

</book>
